#+TITLE:  Emacs Configuration File
#+AUTHOR: Howard Abrams
#+EMAIL:  howard.abrams@gmail.com

* Introduction

  This is my =.emacs= file ... well, the top-level of it anyway.
  I've written it in a [[http://www.orgmode.org][literate style]], to make it easy to explain.
  The notes also include hyperlinks to where I stole it. ;-)

** Emacs Executable

   While I often use [[http://emacsformacosx.com/builds][Emacs for Mac]], lately, I've been building Emacs
   from source using [[http://brew.sh/][Homebrew]]. I start by adding the following dependency:

   #+BEGIN_SRC sh :tangle no
     brew cask install xquartz
   #+END_SRC

   *Note:* I've been running into an issue where I want Emacs to display
   ligatures as well as work with the visual regular expression
   package.  To get the both to work, I find I need to build from
   source after applying [[https://github.com/minimal/emacs/commit/812dd5119645a09bc025a9dddedad9474d12ecb6][this patch]]. According to the Homebrew
   documentation (see [[https://github.com/Homebrew/brew/blob/master/share/doc/homebrew/Formula-Cookbook.md#patches][the Patches section]]), we first:

   #+BEGIN_SRC sh :tangle no
     brew edit emacs
   #+END_SRC

   And add the following section

   #+BEGIN_EXAMPLE
   patch do
     url "https://github.com/minimal/emacs/commit/812dd5119645a09bc025a9dddedad9474d12ecb6.diff"
   end
   #+END_EXAMPLE

   And then build from source especially for the Mac:

   #+BEGIN_SRC sh :tangle no
     brew install emacs --HEAD --use-git-head --with-cocoa --with-gnutls --srgb --with-librsvg --with-ns --with-imagemagick

     brew linkapps emacs
   #+END_SRC

   Not only does this install the latest version of Emacs in
   =/usr/local/bin/emacs=, but it also links a GUI version in
   =/Application/Emacs.app=.

   All Homebrew options for Emacs can be seen with the command:

   #+BEGIN_SRC sh :tangle no
     brew options emacs
   #+END_SRC

** Loading this File

   To "load" the contents of this file, add the following to =$HOME/.emacs=:

   #+BEGIN_SRC elisp :tangle no
     ;; Load our Literate Programming version of our Dot Emacs
     ;; file, from file: ~/Work/dot-files/emacs.org
     (unless (boundp 'aquamacs-version)
      (load-file "~/.emacs.d/elisp/init-main.el")

      (if (window-system)
        (require 'init-client)
        (require 'init-server)

      (server-start))
   #+END_SRC

   I only load this from a "normal" Emacs distribution, which
   allows me to play around with [[http://aquamacs.org/][Aquamacs]] and [[http://eschulte.github.io/emacs-starter-kit/][Starter Kits]].
   You know, to see what I may be missing.

* General Settings
** My Directory Location

   Normally, the =user-emacs-directory= stores everything in a
   =.emacs.d= directory in the home directory, however, Aquamacs
   overrides that, and since I now feel the need to use these settings
   for both editors (sure feels like XEmacs all over again).

   Any way, I have a new global variable for that:

   #+BEGIN_SRC elisp
     (defconst ha/emacs-directory (concat (getenv "HOME") "/.emacs.d/"))

     (defun ha/emacs-subdirectory (d) (expand-file-name d ha/emacs-directory))
   #+END_SRC

** Directory Structure

   In case this is the first time running this on a computer, we need
   to make sure the following directories have been created.

   #+BEGIN_SRC elisp
     (let* ((subdirs '("elisp" "backups" "snippets" "ac-dict"))
            (fulldirs (mapcar (lambda (d) (ha/emacs-subdirectory d)) subdirs)))
       (dolist (dir fulldirs)
         (when (not (file-exists-p dir))
           (message "Make directory: %s" dir)
           (make-directory dir))))
   #+END_SRC

** Customization Section

   While I would rather program my configurations, sometimes the Emacs
   menu system is "good enough", but I want it in its own file:

   #+BEGIN_SRC elisp
     (setq custom-file (expand-file-name "custom.el" ha/emacs-directory))
     (when (file-exists-p custom-file)
       (load custom-file))
   #+END_SRC

** Setting up the Load Path

   Extra packages not available via the package manager go in my
   personal stash at: =$HOME/.emacs.d/elisp=

   #+BEGIN_SRC elisp
     (add-to-list 'load-path (ha/emacs-subdirectory "elisp"))
   #+END_SRC

   Load up my special collection of enhancements to Emacs Lisp:

   #+BEGIN_SRC elisp
     (require 'cl)
     (require 'init-support)
   #+END_SRC

* Package Initialization
** Package Manager

   Emacs has become like every other operating system, and now has a
   [[http://tromey.com/elpa/][package manager]] with its own collection repository, but since it is
   so conservative, we need to add more repositories to get all the
   sweet goodness, I demand.

   #+BEGIN_SRC elisp
     (require 'package)

     (setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                              ("gnu"       . "http://elpa.gnu.org/packages/")
                              ("melpa"     . "http://melpa.milkbox.net/packages/")
                              ("marmalade" . "http://marmalade-repo.org/packages/")))

     (package-initialize)
   #+END_SRC

   The package management system doesn't come with a
   programmatic way to specify what packages /should/ be
   installed. Here is my solution until I convert to [[Use-Package][use-package]].

   #+BEGIN_SRC elisp
     (defun packages-install (packages)
       "Given a list of packages, this will install them from the standard locations."
       (let ((to-install (inverse-filter 'package-installed-p packages)))
         (when to-install
           (package-refresh-contents)
           (dolist (it to-install)
               (package-install it)
           (delete-other-windows)))))
   #+END_SRC

** Use-Package

   Using [[https://github.com/jwiegley/use-package][use-package]] to automatically install certain packages, as
   well as the ease of lazily loading them.

   #+BEGIN_SRC elisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (require 'use-package)
   #+END_SRC

* Variables

  General settings about me that other packages can use. The biggest
  problem is guessing my email address based on what computer I am using:

  #+BEGIN_SRC elisp
    (if (equal "howard.abrams" user-login-name)
        (setq user-mail-address "howard.abrams@workday.com")
      (setq user-mail-address "howard.abrams@gmail.com"))
  #+END_SRC

** Tabs vs Spaces

   I have learned to distrust tabs in my source code, so let's make
   sure that we only have spaces. See [[http://ergoemacs.org/emacs/emacs_tabs_space_indentation_setup.html][this discussion]] for details.

   #+BEGIN_SRC elisp
     (setq-default indent-tabs-mode nil)
     (setq tab-width 2)
   #+END_SRC

   Make tab key do indent first then completion.

   #+BEGIN_SRC elisp
     (setq-default tab-always-indent 'complete)
   #+END_SRC

** Encrypting Files

   Synchronize notes formatted in org-mode across multiple computers
   with cloud storage services, like Dropbox? Those files are /cached/
   in various other storage facilities... so, I use symmetric key
   encryption with [[http://en.wikipedia.org/wiki/Pretty_Good_Privacy][PGP]].

   To get started on the Mac, install the goodies:

   #+BEGIN_SRC sh :tangle no
     brew install gpg
   #+END_SRC

   Now, any file loaded with a =gpg= extension, e.g. =some.org.gpg=,
   will prompt for a password (and then use =org-mode=).  Since these
   files are for my eyes only, I don‚Äôt need the key-ring prompt:

   #+BEGIN_SRC elisp
     (setq epa-file-select-keys 2)
   #+END_SRC

   If you trust your Emacs session on your computer, you can have
   Emacs cache the password. Not sure I do...

   #+BEGIN_SRC elisp
     (setq epa-file-cache-passphrase-for-symmetric-encryption t)
   #+END_SRC

* Display Settings

  I've been using Emacs for many years, and appreciate a certain
  minimalist approach to its display. While you can turn these off
  with the menu items now, it is just as easy to set them here.

  #+BEGIN_SRC elisp
    (setq initial-scratch-message "") ;; Uh, I know what Scratch is for
    (setq visible-bell t)             ;; Get rid of the beeps

    (when (window-system)
      (tool-bar-mode 0)               ;; Toolbars were only cool with XEmacs
      (when (fboundp 'horizontal-scroll-bar-mode)
        (horizontal-scroll-bar-mode -1))
      (scroll-bar-mode -1))            ;; Scrollbars are waste screen estate
  #+END_SRC

  Most of the display settings actually come from the [[file:emacs-mac.org][Mac initialization file]].

** Mode Line

   My [[file:emacs-mode-line.org][mode-line code]] is now more complex in order to make it more simpler.

   #+BEGIN_SRC elisp
     (require 'init-mode-line)
   #+END_SRC

** Whitespace Mode

   You don't want this on all the time, but nice to turn it on every
   now and then:

   #+BEGIN_SRC elisp
     (use-package whitespace
       :bind ("C-c T w" . whitespace-mode)
       :init
       (setq whitespace-line-column nil
             whitespace-display-mappings '((space-mark 32 [183] [46])
                                           (newline-mark 10 [9166 10])
                                           (tab-mark 9 [9654 9] [92 9])))
       :config
       (set-face-attribute 'whitespace-space       nil :foreground "#666666" :background nil)
       (set-face-attribute 'whitespace-newline     nil :foreground "#666666" :background nil)
       (set-face-attribute 'whitespace-indentation nil :foreground "#666666" :background nil)
       :diminish whitespace-mode)
   #+END_SRC

** Fill Mode

   Automatically wrapping when you get to the end of a line (or the
   fill-region):

   #+BEGIN_SRC elisp
     (use-package fill
       :bind ("C-c T f" . auto-fill-mode)
       :init (add-hook 'org-mode-hook 'turn-on-auto-fill)
       :diminish auto-fill-mode)
   #+END_SRC

* Key Bindings
** Hydra Sequences

   I‚Äôm starting to appreciate the [[https://github.com/abo-abo/hydra][Hydra project]].

   #+BEGIN_SRC elisp
     (use-package hydra
       :ensure t
       :config
       (hydra-add-font-lock))
   #+END_SRC

   Easily manipulate the size of the windows using the arrow keys in a
   particular buffer window.

   #+BEGIN_SRC elisp
     (require 'windmove)

     (defun hydra-move-splitter-left (arg)
       "Move window splitter left."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'right))
           (shrink-window-horizontally arg)
         (enlarge-window-horizontally arg)))

     (defun hydra-move-splitter-right (arg)
       "Move window splitter right."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'right))
           (enlarge-window-horizontally arg)
         (shrink-window-horizontally arg)))

     (defun hydra-move-splitter-up (arg)
       "Move window splitter up."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'up))
           (enlarge-window arg)
         (shrink-window arg)))

     (defun hydra-move-splitter-down (arg)
       "Move window splitter down."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'up))
           (shrink-window arg)
         (enlarge-window arg)))

     (defhydra hydra-splitter (global-map "<f9>")
       "splitter"
       ("<left>" hydra-move-splitter-left)
       ("<down>" hydra-move-splitter-down)
       ("<up>" hydra-move-splitter-up)
       ("<right>" hydra-move-splitter-right))
   #+END_SRC

   Other Hydra sequences are associated with the package they control.

** Displaying Command Sequences

   Many command sequences may be logical, but who can remember them
   all? While I used to use [[https://github.com/kai2nenobu/guide-key][guide-key]] to display the final function
   name, it isn't as nice as [[https://github.com/justbur/emacs-which-key][which-key]].

   #+BEGIN_SRC elisp
     (use-package which-key
       :ensure t
       :defer 10
       :config

       ;; Replacements for how KEY is replaced when which-key displays
       ;;   KEY ‚Üí FUNCTION
       ;; Eg: After "C-c", display "right ‚Üí winner-redo" as "‚ñ∂ ‚Üí winner-redo"
       (setq which-key-key-replacement-alist
             '(("<\\([[:alnum:]-]+\\)>" . "\\1")
               ("left"                  . "‚óÄ")
               ("right"                 . "‚ñ∂")
               ("up"                    . "‚ñ≤")
               ("down"                  . "‚ñº")
               ("delete"                . "DEL") ; delete key
               ("\\`DEL\\'"             . "BS") ; backspace key
               ("next"                  . "PgDn")
               ("prior"                 . "PgUp"))

             ;; List of "special" keys for which a KEY is displayed as just
             ;; K but with "inverted video" face... not sure I like this.
             which-key-special-keys '("RET" "DEL" ; delete key
                                      "ESC" "BS" ; backspace key
                                      "SPC" "TAB")

             ;; Replacements for how part or whole of FUNCTION is replaced:
             which-key-description-replacement-alist
             '(("Prefix Command" . "prefix")
               ("\\`calc-"       . "") ; Hide "calc-" prefixes when listing M-x calc keys
               ("/body\\'"       . "") ; Remove display the "/body" portion of hydra fn names
               ("\\`projectile-" . "ùìü/")
               ("\\`hydra-"      . "+ùêá/")
               ("\\`org-babel-"  . "ob/"))

             ;; Underlines commands to emphasize some functions:
             which-key-highlighted-command-list
             '(("\\`hydra-" . which-key-group-description-face)
               "\\(rectangle-\\)\\|\\(-rectangle\\)"
               "\\`org-"))

       ;; Change what string to display for a given *complete* key binding
       ;; Eg: After "C-x", display "8 ‚Üí +unicode" instead of "8 ‚Üí +prefix"
       (which-key-add-key-based-replacements
         "C-x 8"   "unicode"
         "C-c T"   "toggles-"
         "C-c p s" "projectile-search"
         "C-c p 4" "projectile-other-buffer-"
         "C-x a"   "abbrev/expand"
         "C-x r"   "rect/reg"
         "C-c /"   "engine-mode-map"
         "C-c C-v" "org-babel")

       (which-key-mode 1))
   #+END_SRC

** Function Key Definitions

   Emacs has never seen a need for function keys, and I agree...for
   the most part. For things really /away from the flow/, they don't
   seem to bad. But what are those?

   - *F1* - Help? Isn't Control-H good enough?
   - *F2* - Special odd, little-used characters that I have to think
            about before remembering what its binding.
   - *F3* - Define a keyboard macro
   - *F4* - Replay a keyboard macro
   - *F5* - Use org-mode‚Äôs Mark Ring feature globally
   - *F6* - Open to temporary, changeable commands...
   - *F7* - Switch to another window ... Control goes the other way.
   - *F8* - Switch to buffer
   - *F9* - My extension (replacement?) for =C-c= for changing colors
     and other odd bindings that I actually don't use that often.

   #+BEGIN_SRC elisp
     (global-set-key (kbd "<f5>") 'org-mark-ring-push)
     (global-set-key (kbd "C-<f5>") 'org-mark-ring-goto)
     (global-set-key (kbd "<f7>") 'other-window)
     (global-set-key (kbd "C-<f7>") (lambda () (interactive) (other-window -1)))
   #+END_SRC

*** F2 and F9 Helpers

    The F9 prefix is scattered about my config files.

    #+BEGIN_SRC elisp
      (define-prefix-command 'personal-global-map)
      (global-set-key (kbd "<f9>") 'personal-global-map)
    #+END_SRC

    Unlike the *F9* bindings, all the *F2* key-bindings happen in a
    single [[file:emacs-f2.org][library file]]:

    #+BEGIN_SRC elisp
      (require 'init-f2)
    #+END_SRC

** Highlighting and Narrowing

   I like the ability to highlight random text.

   - =M-s h .= :: highlight-symbol-at-point
   - =M-s h l= :: highlight-lines-matching-regexp
   - =M-s h p= :: highlight-phrase
   - =M-s h r= :: highlight-regexp
   - =M-s h u= :: unhighlight-regexp

   May get specific highlights automatically for certain files. We
   begin by highlighting lines in *.log files.

   #+BEGIN_SRC elisp
     (defun ha/highlite-logs ()
       "Highlight certain lines in specific files. Currently, only log files are supported."
       (interactive)
       (when (equal "log" (file-name-extension (buffer-file-name)))
             (hi-lock-mode 1)
             (highlight-lines-matching-regexp "ERROR:" 'hi-red-b)
             (highlight-lines-matching-regexp "NOTE:" 'hi-blue-b)))
   #+END_SRC

   The condition in this function that checks for the =log= extension,
   allows me to hook it to the loading of any file:

   #+BEGIN_SRC elisp :tangle no
     (add-hook 'find-file-hook 'ha/highlite-logs)
   #+END_SRC

   Turn on specific word groupings for specific occasions. We begin
   with highlighting keywords I use during note-taking sessions at
   the end of a sprint.

   #+BEGIN_SRC elisp
     (defun ha/sprint-retrospective-highlighting ()
       "Highlights the good, the bad and the improvements to make when taking notes."
       (interactive)
       (hi-lock-mode t)
       (highlight-lines-matching-regexp "^   [-*] " 'hi-black-b)
       (highlight-phrase "TODO:?" 'hi-black-b)
       (highlight-regexp "(?Good)?:?" 'hi-green-b)
       (highlight-regexp "(?Bad)?:?" 'hi-red-b)
       (highlight-regexp "Imp\\(rove\\)?:" 'hi-blue-b))
   #+END_SRC

   This works really well with other commands, including
   [[https://github.com/Bruce-Connor/fancy-narrow][fancy-narrow]], where I can visually high-light a section of a
   buffer. Great for code-reviews and other presentations.

   #+BEGIN_SRC elisp
     (use-package fancy-narrow
       :ensure t
       :config
       (defun ha/highlight-block ()
         "Highlights a 'block' in a buffer defined by the first blank
          line before and after the current cursor position. Uses the
          'fancy-narrow' mode to high-light the block."
         (interactive)
         (let (cur beg end)
           (setq cur (point))
           (setq end (or (re-search-forward  "^\s*$" nil t) (point-max)))
           (goto-char cur)
           (setq beg (or (re-search-backward "^\s*$" nil t) (point-min)))
           (fancy-narrow-to-region beg end)
           (goto-char cur)))

       (defun ha/highlight-section (num)
         "If some of the buffer is highlighted with the `fancy-narrow'
          mode, then un-highlight it by calling `fancy-widen'.

          If region is active, call `fancy-narrow-to-region'.

          If NUM is 0, highlight the current block (delimited by blank
          lines). If NUM is positive or negative, highlight that number
          of lines.  Otherwise, called `fancy-narrow-to-defun', to
          highlight current function."
         (interactive "p")
         (cond
          ((fancy-narrow-active-p)  (fancy-widen))
          ((region-active-p)        (fancy-narrow-to-region (region-beginning) (region-end)))
          ((= num 0)                (ha/highlight-block))
          ((= num 1)                (fancy-narrow-to-defun))
          (t                        (progn (ha/expand-region num)
                                           (fancy-narrow-to-region (region-beginning) (region-end))))))

       :bind ("C-M-+" . ha/highlight-section))
   #+END_SRC

   This nifty function from [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Endless Parenthesis]] is a nice replacement
   for many other narrowing keybindings that I use:

   #+BEGIN_SRC elisp
     (defun narrow-or-widen-dwim (p)
       "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
     Intelligently means: region, subtree, or defun, whichever applies
     first.

     With prefix P, don't widen, just narrow even if buffer is already
     narrowed."
       (interactive "P")
       (declare (interactive-only))
       (cond ((and (buffer-narrowed-p) (not p)) (widen))
             ((region-active-p)
              (narrow-to-region (region-beginning) (region-end)))
             ((derived-mode-p 'org-mode) (org-narrow-to-subtree))
             (t (narrow-to-defun))))

     (global-set-key (kbd "C-x n x") 'narrow-or-widen-dwim)
   #+END_SRC

** Jumping to Windows

  Set up [[https://github.com/abo-abo/ace-window][ace-window]] mode:

  #+BEGIN_SRC elisp
    (use-package ace-window
      :ensure t
      :init
        (setq aw-keys '(?a ?s ?d ?f ?j ?k ?l ?o))
        (global-set-key (kbd "C-x o") 'ace-window)
      :diminish ace-window-mode)
  #+END_SRC

** Selecting a Buffer

   I like =IDO= for switching buffers since I typically know what I'm after:

   #+BEGIN_SRC elisp
    (global-set-key (kbd "<f8>") 'ido-switch-buffer)
    (global-set-key (kbd "S-<f8>") 'ibuffer)
   #+END_SRC

   I like [[https://github.com/KMahoney/kpm-list][kpm-list]] a bit better than =ibuffer=, but I really don‚Äôt use
   either more than =ido-switch-buffer=. Still:

   #+BEGIN_SRC elisp
    (use-package kpm-list
      :ensure t
      :bind ("S-<f8>" . kpm-list)
            ("C-x C-b" . kpm-list))
   #+END_SRC

** Controlling Window Size

   Often, while on my laptop, I want the current window to be ‚Äòlarge
   enough for work‚Äô, and this is bound to =<f9> .= (period).

   #+BEGIN_SRC elisp
     (global-unset-key (kbd "C-c w"))
     (global-set-key (kbd "C-c w r") 'ha/window-standard-size)
   #+END_SRC

   If I've enlarged the window, I can restore that window to its
   original size, so this requires a /buffer local variable/:

   #+BEGIN_SRC elisp
     (make-variable-buffer-local 'window-width-original)
   #+END_SRC

   Now a function that either changes the width to 80, or back to the
   original size if already at 80.

   #+BEGIN_SRC elisp
     (defun ha/window-standard-size (arg)
       "Sets the size of the current window to 80 characters, unless
     it already is 80 characters, in which case, set it back to its
     previous size. A prefix ARG can be given to set the window to a
     particular width."
       (interactive "p")

       ;; If not already set, let's store the current window width in our
       ;; buffer-local variable.
       (if (not (local-variable-p 'window-width-original))
           (setq window-width-original (window-width)))

       ;; The 'goal' is 80 unless we get a better argument, C-u 60 ...
       (let* ((goal-width (if (> arg 8) arg 80))
              (new-width (- goal-width (window-width))))

         (if (= new-width 0)    ; Already enlarged? Restore:
             (enlarge-window-horizontally (- window-width-original goal-width))
           (enlarge-window-horizontally new-width))))
   #+END_SRC

** Controlling Window Placement

   Change window configuration and then return to the old
   configuration with [[http://www.emacswiki.org/emacs/WinnerMode][winner-mode]].  Use =Control-C Arrow= keys to
   cycle through window/frame configurations.

   #+BEGIN_SRC elisp
     (use-package winner
       :ensure t
       :init (winner-mode 1))
   #+END_SRC

   While =winner-mode= is easy to keep the current window configuration
   /clean/, the [[https://github.com/wasamasa/eyebrowse][eyebrowse]] project seems to have a good approach to
   managing multiple configurations.

   #+BEGIN_SRC elisp
     (use-package eyebrowse
        :ensure t
        :init   (eyebrowse-mode t))
   #+END_SRC

** Better Jumping

   Mostly using the [[https://github.com/abo-abo/avy][avy]] project's [[help:avy-goto-word-1][avy-goto-word-1]] function, so I bind
   that to =C-c j=, but the recent update to include a timer feature,
   seems awful sweet:

   #+Begin_SRC elisp
     (use-package avy
       :ensure t
       :commands avy-goto-word-1 avy-goto-char-1 avy-goto-line avy-goto-char-timer
       :bind
       ("C-c j"   . avy-goto-word-1)
       ("A-j"     . avy-goto-word-1)    ; The Mac Command key
       ("s-j"     . avy-goto-word-1)    ; The Command key on Linux
       ("A-h"     . avy-goto-char-2)
       ("s-h"     . avy-goto-char-2)
       ("C-c k k" . avy-goto-char-timer)
       ("A-J"     . avy-goto-char-timer)    ; The Mac Command key
       ("s-J"     . avy-goto-char-timer)    ; The Command key on Linux
       ("C-c k j" . avy-goto-word-1)
       ("C-c k c" . avy-goto-char-1)
       ("C-c k l" . avy-goto-line)
       ("C-c k p" . avy-pop-mark)
       ("A-,"     . avy-pop-mark))
   #+END_SRC

   Other options (that require more of my memory), are bound
   to =C-c k=.

** Unfill Paragraph

   Unfilling a paragraph joins all the lines in a paragraph into a
   single line. Taken from [[http://www.emacswiki.org/UnfillParagraph][here]].

   #+BEGIN_SRC elisp
     (defun unfill-paragraph ()
       "Takes a multi-line paragraph and makes it into a single line of text."
       (interactive)
       (let ((fill-column (point-max)))
         (fill-paragraph nil)))

     ;; Handy key definition
     (define-key global-map "\M-Q" 'unfill-paragraph)
   #+END_SRC

** General Behavior Fixes

   The subtle changes I've been making to Emacs behavior has grown
   until I felt I should move it into [[file:emacs-fixes.org][its own source file]].

   #+BEGIN_SRC elisp
     (require 'init-fixes)
   #+END_SRC

** Multiple Cursors

   While I'm not sure how often I will use [[https://github.com/emacsmirror/multiple-cursors][multiple-cursors]] project,
   I'm going to try to remember it is there. It doesn't have any
   default keybindings, so I set up the suggested:

   #+BEGIN_SRC elisp
     (use-package multiple-cursors
       :ensure t
       :config
       (global-set-key
        (kbd "C-c C-.")
        (defhydra hydra-multiple-cursors ()
          "multiple-cursors"
          ("." mc/mark-all-dwim                   "all-dwim")
          ("C-." mc/mark-all-like-this-dwim       "all-like-dwim")
          ("n" mc/mark-next-like-this             "next")
          ("p" mc/mark-previous-like-this         "previous")
          ("a" mc/mark-all-like-this              "mark-all")
          ("N" mc/mark-next-symbol-like-this      "next-symbol")
          ("P" mc/mark-previous-symbol-like-this  "previous-symbol")
          ("A" mc/mark-all-symbols-like-this      "all-symbols")
          ("f" mc/mark-all-like-this-in-defun     "in-func")
          ("l" mc/edit-lines                      "all-lines")
          ("e" mc/edit-ends-of-lines              "end-lines"))))
   #+END_SRC

** Expand Region

   Wherever you are in a file, and whatever the type of file, you can
   slowly increase a region selection by logical segments by using
   Magnar's [[https://github.com/magnars/expand-region.el][expand-region]] project.

   However, the normal experience for =expand-region= is interactive,
   expected to be called repeatedly to expand and contract the regions
   based on syntax, and whatnot. Since I am seldom sure what I will
   select if I give this function a numeric prefix, I created a
   wrapper function that will (when given a number), just select the
   number of lines for the region. Select the current line with a 0
   argument. No argument (well, =lines= is given 1 with no argument),
   then it just calls =expand-region=:

   #+BEGIN_SRC elisp
     (use-package expand-region
       :ensure t
       :config
       (defun ha/expand-region (lines)
         "Prefix-oriented wrapper around Magnar's `er/expand-region'.

     Call with LINES equal to 1 (given no prefix), it expands the
     region as normal.  When LINES given a positive number, selects
     the current line and number of lines specified.  When LINES is a
     negative number, selects the current line and the previous lines
     specified.  Select the current line if the LINES prefix is zero."
         (interactive "p")
         (cond ((= lines 1)   (er/expand-region 1))
               ((< lines 0)   (ha/expand-previous-line-as-region lines))
               (t             (ha/expand-next-line-as-region (1+ lines)))))

       (defun ha/expand-next-line-as-region (lines)
         (message "lines = %d" lines)
         (beginning-of-line)
         (set-mark (point))
         (end-of-line lines))

       (defun ha/expand-previous-line-as-region (lines)
         (end-of-line)
         (set-mark (point))
         (beginning-of-line (1+ lines)))

       :bind ("C-=" . ha/expand-region))
   #+END_SRC

** Block Wrappers

   While the =M-(= binding to =insert-pair= is great, I often need to
   wrap with other characters:

   #+BEGIN_SRC elisp
     (global-set-key (kbd "M-[") 'insert-pair)
     (global-set-key (kbd "M-{") 'insert-pair)
     (global-set-key (kbd "M-<") 'insert-pair)
     (global-set-key (kbd "M-'") 'insert-pair)
     (global-set-key (kbd "M-`") 'insert-pair)
     (global-set-key (kbd "M-\"") 'insert-pair)
   #+END_SRC

   But [[https://github.com/rejeep/wrap-region.el][wrap-region]] is even more flexible. In most editors, selecting
   text and typing anything replaces the selected text (see the
   [[info:emacs#Using%20Region][delete-selection-mode]]), but in this case, we can do something
   different... like wrapping:

   #+BEGIN_SRC elisp
     (use-package wrap-region
       :ensure   t
       :config
       (wrap-region-global-mode t)
       (wrap-region-add-wrappers
        '(("(" ")")
          ("[" "]")
          ("{" "}")
          ("<" ">")
          ("'" "'")
          ("\"" "\"")
          ("‚Äò" "‚Äô"   "q")
          ("‚Äú" "‚Äù"   "Q")
          ("*" "*"   "b"   org-mode)                 ; bolden
          ("*" "*"   "*"   org-mode)                 ; bolden
          ("/" "/"   "i"   org-mode)                 ; italics
          ("/" "/"   "/"   org-mode)                 ; italics
          ("~" "~"   "c"   org-mode)                 ; code
          ("~" "~"   "~"   org-mode)                 ; code
          ("=" "="   "v"   org-mode)                 ; verbatim
          ("=" "="   "="   org-mode)                 ; verbatim
          ("_" "_"   "u" '(org-mode markdown-mode))  ; underline
          ("**" "**" "b"   markdown-mode)            ; bolden
          ("*" "*"   "i"   markdown-mode)            ; italics
          ("`" "`"   "c" '(markdown-mode ruby-mode)) ; code
          ("`" "'"   "c"   lisp-mode)                ; code
          ))
       :diminish wrap-region-mode)
   #+END_SRC

   But in order to wrap text in a more general way (with just about
   any textual string), we need something more. Especially with the
   =expand-region= command, wrapping a logical block of text with a
   beginning and ending string really makes sense.

   #+BEGIN_SRC elisp
     (defun surround (start end txt)
       "Wraps the specified region (or the current 'symbol / word'
     with some textual markers that this function requests from the
     user. Opening-type text, like parens and angle-brackets will
     insert the matching closing symbol.

     This function also supports some org-mode wrappers:

       - `#s` wraps the region in a source code block
       - `#e` wraps it in an example block
       - `#q` wraps it in an quote block"
       (interactive "r\nsEnter text to surround: " start end txt)

       ;; If the region is not active, we use the 'thing-at-point' function
       ;; to get a "symbol" (often a variable or a single word in text),
       ;; and use that as our region.

       (if (not (region-active-p))
           (let ((new-region (bounds-of-thing-at-point 'symbol)))
             (setq start (car new-region))
             (setq end (cdr new-region))))

       ;; We create a table of "odd balls" where the front and the end are
       ;; not the same string.
       (let* ((s-table '(("#e" . ("#+BEGIN_EXAMPLE\n" "\n#+END_EXAMPLE") )
                         ("#s" . ("#+BEGIN_SRC \n"    "\n#+END_SRC") )
                         ("#q" . ("#+BEGIN_QUOTE\n"   "\n#+END_QUOTE"))
                         ("<"  . ("<" ">"))
                         ("("  . ("(" ")"))
                         ("{"  . ("{" "}"))
                         ("["  . ("[" "]"))))    ; Why yes, we'll add more
              (s-pair (assoc-default txt s-table)))

         ;; If txt doesn't match a table entry, then the pair will just be
         ;; the text for both the front and the back...
         (unless s-pair
           (setq s-pair (list txt txt)))

         (save-excursion
           (narrow-to-region start end)
           (goto-char (point-min))
           (insert (car s-pair))
           (goto-char (point-max))
           (insert (cadr s-pair))
           (widen))))

     (global-set-key (kbd "C-+") 'surround)
   #+END_SRC

   To make it easier to call from other functions, let's wrap that
   wrapper:

   #+BEGIN_SRC elisp
     (defun surround-text (txt)
       (if (region-active-p)
           (surround (region-beginning) (region-end) txt)
         (surround nil nil txt)))
   #+END_SRC

   This function returns an interactive lambda expression, suitable
   for adding to a key-binding:

   #+BEGIN_SRC elisp
     (defun surround-text-with (surr-str)
       "Returns an interactive function that when called, will surround the region (or word) with the SURR-STR string."
       (lexical-let ((text surr-str))
         (lambda ()
           (interactive)
           (surround-text text))))
   #+END_SRC

* Loading and Finding Files
** Projectile

   The [[https://github.com/bbatsov/projectile][Projectile]] project is a nifty way to run commands and search
   for files in a particular "project". Its necessity is less now that
   IDO with flexible matching seems to always just find what I need.

   #+BEGIN_SRC elisp
     (use-package projectile
       :ensure t
       :init (projectile-global-mode 1)
       :commands projectile-ag
       :config
       (setq projectile-switch-project-action 'projectile-commander
             projectile-completion-system 'ido
             projectile-create-missing-test-files t)
       (add-to-list 'projectile-globally-ignored-files ".DS_Store")

       (def-projectile-commander-method ?d
         "Open project root in dired."
         (projectile-dired))

       (def-projectile-commander-method ?s
         "Open a *shell* buffer for the project."
         (projectile-run-shell))

       (def-projectile-commander-method ?F
         "Git fetch."
         (magit-status)
         (call-interactively #'magit-fetch-current))

       (def-projectile-commander-method ?j
         "Jack-in with Cider."
         (let* ((opts (projectile-current-project-files))
                (file (ido-completing-read
                       "Find file: "
                       opts
                       nil nil nil nil
                       (car (cl-member-if
                             (lambda (f)
                               (string-match "core\\.clj\\'" f))
                             opts)))))
           (find-file (expand-file-name
                       file (projectile-project-root)))
           (run-hooks 'projectile-find-file-hook)
           (cider-jack-in))))
   #+END_SRC

  Much of the previous section came from [[http://endlessparentheses.com/improving-projectile-with-extra-commands.html][this essay]].

** Dired Options

   Between =M-!= and starting [[Eshell][Eshell]], comes =dired= (=C-x d=).

   #+BEGIN_SRC elisp
     (setq ls-lisp-use-insert-directory-program nil)
   #+END_SRC

   This enhancement to dired hides the ugly details until you hit
   '(' and shows the details with ')'. I also change the [...] to a
   simple asterisk.

   #+BEGIN_SRC elisp
     (use-package dired-details
       :ensure t
       :init   (setq dired-details-hidden-string "* ")
       :config (dired-details-install))
   #+END_SRC

   The ability to create a dired buffer based on searching for files
   in a directory tree with =find-name-dired= is fantastic. The
   [[http://www.masteringemacs.org/articles/2011/03/25/working-multiple-files-dired/][following magic]] optimizes this approach:

   #+BEGIN_SRC elisp
     (use-package find-dired
        :ensure t
        :init (setq find-ls-option '("-print0 | xargs -0 ls -od" . "-od")))
   #+END_SRC

   The [[http://pragmaticemacs.com/emacs/quickly-preview-images-and-other-files-with-peep-dired/][peep project]] allows you to preview files before loading them
   into a dedicated buffer:

   #+BEGIN_SRC elisp
     (use-package peep-dired
       :defer t ; don't access `dired-mode-map' until `peep-dired' is loaded
       :bind (:map dired-mode-map
                   ("P" . peep-dired)))
   #+END_SRC

   The [[http://www.masteringemacs.org/articles/2014/04/10/dired-shell-commands-find-xargs-replacement/][dired-x project]] seems useful:

   #+BEGIN_SRC elisp
     (require 'dired-x)
   #+END_SRC

** Tramp

   The ability to edit files on remote systems is a wonderful win,
   since it means I don't need to have my Emacs environment running on
   remote machines (still a possibility, just not a requirement).

   According to [[http://www.gnu.org/software/emacs/manual/html_node/tramp/Filename-Syntax.html][the manual]], I can access a file over SSH, via:

   #+BEGIN_EXAMPLE
   /ssh:10.52.224.67:blah
   #+END_EXAMPLE

   If I set the default method to SSH, I can do this:

   #+BEGIN_EXAMPLE
   /10.52.224.67:blah
   #+END_EXAMPLE

   So, let's do it...

   #+BEGIN_SRC elisp
     (setq tramp-default-method "ssh")
   #+END_SRC

** Remote Shell Interface

   All the shell functions that Emacs supplies work with Tramp
   references. This makes it very easy to spawn a shell, or a shell
   command on a remote system...even as root.

   Since the Tramp syntax is a bit verbose, a few /wrapper functions/
   would make things easier. Also, having a list of /favorite hosts/
   with simpler names would also be a nice feature.

   Since Emacs doesn't have a memoize function, define a global
   variable, =remote-shell-fav-hosts=, a hash that maps nicknames of
   hosts to their IP address.

   #+BEGIN_SRC elisp
    (defvar remote-shell-fav-hosts (make-hash-table :test 'equal)
      "Table of host aliases for IPs or other actual references.")
   #+END_SRC

   Can we make a list of what hosts are /pre-known/? What if no hosts
   have been defined? In this case, we want to call the function,
   =remote-shell-fav-hosts-get= to populate it:

   #+BEGIN_SRC elisp
     (defun remote-shell-fav-hosts-map ()
       "Returns the mapping between our simple names of our favorite
     hosts and their IP address. If the map is empty, and the function
     `remote-shell-fav-hosts-get' has been defined, it calls that
     function to populate the map prior to returning it. This may
     return an empty map."
       (when (and #'remote-shell-fav-hosts-get
                  (hash-table-empty-p remote-shell-fav-hosts))
         (remote-shell-fav-hosts-get))
       remote-shell-fav-hosts)
   #+END_SRC

   In order to populate the =completing-read=, we need a list of hosts:

   #+BEGIN_SRC elisp
     (defun remote-shell-fav-hosts-list ()
       "Simply returns a list of known hosts from the cached map, or
     populates it first if it is empty and the
     `remote-shell-fav-hosts-get' function has been defined."
       (hash-table-keys (remote-shell-fav-hosts-map)))
   #+END_SRC

   Most remote access is done with Tramp, so this function simplifies
   the complex Tramp string creation, mostly using an =sudo= pipe for
   =root= access. If the =remote-shell-fav-hosts= hash is empty, we'll
   populate it when this is called.

   #+BEGIN_SRC elisp
     (defun remote-shell-tramp-connection (hostname &optional root directory)
       "Return a TRAMP connection string to HOSTNAME. If ROOT is
     non-nil, returns an sudo compatible string."
       (when (null directory)
         (setq directory ""))

       ;; The ip address is either the value from a key in our cache, or whatever we pass in:
       (let ((ipaddr (gethash hostname (remote-shell-fav-hosts-map) hostname)))
         (if root
             (format "/ssh:%s|sudo:%s:%s" ipaddr ipaddr directory)
             (format "/ssh:%s:%s"         ipaddr directory))))
   #+END_SRC

   If the window containing the results of the shell connection or
   shell command is the same, we can take advantage of that from
   multiple functions, so:

   #+BEGIN_SRC elisp
     (defun remote-shell-buffer-name (hostname &optional command-str default-name)
       "Returns a standard format for our remote shell command buffer
     windows based on the HOSTNAME and the COMMAND-STR. Uses
     DEFAULT-NAME if specified."
       (cond
        (default-name     default-name)
        (command-str      (let ((command (car (split-string command-str))))
                             (format "*%s:%s*" hostname command)))
        (t                (format "*%s*" hostname))))
   #+END_SRC

   Our simple wrapper function for accessing a remote shell, should
   use =ido= if available.

   #+BEGIN_SRC elisp
     (defun remote-shell (hostname &optional root)
       "Start an shell experience on HOSTNAME, that can be an alias to
     a virtual machine in the overcloud. With prefix command, opens
     the shell as the root user account."
       (interactive
        (list (if #'ido-completing-read
                  (ido-completing-read "Hostname: " (remote-shell-fav-hosts-list))
                (completing-read "Hostname: " (remote-shell-fav-hosts-list)))))

       (when (equal current-prefix-arg '(4))
         (setq root t))
       (let ((default-directory (remote-shell-tramp-connection hostname root)))
         (shell (remote-shell-buffer-name hostname))))
   #+END_SRC

   Instead of starting a shell, what if we just ran a command using the
   =shell-command= (so that commands that end in a =&= are automatically
   ran asynchronously.

   #+BEGIN_SRC elisp
     (defun remote-shell-command (hostname command
                                           &optional root bufname directory)
         "On HOSTNAME, run COMMAND (if the command ends with &, run
     asynchronously). With a `C-u' prefix, run the command as ROOT.
     When non-interactive, you can specify BUFNAME for the buffer's
     name, and DIRECTORY where the command should run."
       (interactive
        (list (if #'ido-completing-read
                  (ido-completing-read "Hostname: " (remote-shell-fav-hosts-list))
                (completing-read "Hostname: " (remote-shell-fav-hosts-list)))))

       (when (equal current-prefix-arg '(4))
         (setq root t))
       (let ((default-directory (remote-shell-tramp-connection hostname root directory)))
           (shell-command command (remote-shell-buffer-name hostname command bufname))))
   #+END_SRC

   With the above helper functions, we can loop over a list of machines,
   and kick off remote work on each one:

   #+BEGIN_SRC elisp
     (defun remote-shell-commands (clients command
                                           &optional root async directory)
       "On each host entry in CLIENTS, run the shell COMMAND,
     optionally as ROOT. If ASYNC is non-nil, appends the `&' to the
     shell command in order to run it asynchronously. Runs the command
     in the default home directory unless DIRECTORY is specified."
       (if async
           (setq command (concat command " &")))
       (dolist (host clients)
         (remote-shell-command host command root nil directory)))
   #+END_SRC

   The results of each command is stored in a separate buffer, and
   since we know what the names are, this command will attempt to load
   them on the side... yeah, this is a bit ugly.

   #+BEGIN_SRC elisp
     (defun remote-shell-commands-show (clients command)
       "Shows each buffer of a previously executed command. For example:

             (let ((my-favs '(\"os-controller\" \"contrail-controller\"
                              \"compute\" \"nagios\" \"elk\"))
                   (command \"chef-client\"))
               (remote-shell-commands my-favs command t t)
               (remote-shell-commands-show my-favs command))"

       (delete-other-windows)
       (let ((first-time t))
         (dolist (host clients)
           (if (not first-time)
               (split-window-vertically)
             (split-window-horizontally)
             (setq first-time nil))

           (other-window 1)
           (switch-to-buffer (remote-shell-buffer-name host command))
           (balance-windows)
           (sit-for 0.5))))
   #+END_SRC

   All this work allows me to do magic:

   #+BEGIN_SRC elisp :tangle no
     (let ((my-favs '("os-controller" "contrail-controller"
                      "compute" "nagios" "elk"))
           (command "chef-client"))
       (remote-shell-commands my-favs command t t)
       (remote-shell-commands-show my-favs command))
   #+END_SRC

   Check out this [[https://www.youtube.com/watch?v=pSjrwSI4OHk][YouTube video recording]] of this section in action.
** Editing Root Files

   According to [[http://emacs-fu.blogspot.com/2013/03/editing-with-root-privileges-once-more.html][Emacs Fu]], we can use the wonderful Tramp to edit
   Root-owned files, as in:

   #+BEGIN_SRC elisp
     (defun ha/find-file-as-root ()
       "Like `ido-find-file, but automatically edit the file with
     root-privileges (using tramp/sudo), if the file is not writable by
     user."
       (interactive)
       (let ((file (ido-read-file-name "Edit as root: ")))
         (unless (file-writable-p file)
           (setq file (concat "/sudo:root@localhost:" file)))
         (find-file file)))
   #+END_SRC

   The trick, as always, is finding the correct keybinding... but I
   have the =C-c f= as prefix for loading all sorts of files...

   #+BEGIN_SRC elisp
     (global-set-key (kbd "C-c f r") 'ha/find-file-as-root)
   #+END_SRC

** IDO (Interactively DO Things)

   According to [[http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/][Mickey]], IDO is the greatest thing.

   #+BEGIN_SRC elisp
     (use-package ido
       :ensure t
       :init  (setq ido-enable-flex-matching t
                    ido-ignore-extensions t
                    ido-use-virtual-buffers t
                    ido-everywhere t)
       :config
       (ido-mode 1)
       (ido-everywhere 1)
       (add-to-list 'completion-ignored-extensions ".pyc"))
   #+END_SRC

   Add to IDO, the [[https://github.com/lewang/flx][FLX]] package:

   #+BEGIN_SRC elisp
     (use-package flx-ido
        :ensure t
        :init (setq ido-enable-flex-matching t
                    ido-use-faces nil)
        :config (flx-ido-mode 1))
   #+END_SRC

   According to [[https://gist.github.com/rkneufeld/5126926][Ryan Kneufeld]], we could make IDO work vertically,
   which is much easier to read. For this, I use [[https://github.com/gempesaw/ido-vertical-mode.el][ido-vertically]]:

   #+BEGIN_SRC elisp
     (use-package ido-vertical-mode
       :ensure t
       :init               ; I like up and down arrow keys:
       (setq ido-vertical-define-keys 'C-n-C-p-up-and-down)
       :config
       (ido-vertical-mode 1))
   #+END_SRC

** SMEX

   Built using [[*IDO%20(Interactively%20DO%20Things)][IDO]] to do something similar but with =M-x= commands:

   #+BEGIN_SRC elisp
     (use-package smex
       :ensure t
       :init (smex-initialize)
       :bind ("M-x" . smex)
             ("M-X" . smex-major-mode-commands))
   #+END_SRC

** Helm

   Obviously, Helm would be helpful if I can learn all the bindings,
   so:

   #+BEGIN_SRC elisp
     (use-package helm
       :ensure t
       :init
       (use-package helm-config))   ;; Binds C-x c to the helm bidness.
   #+END_SRC

   Re-read [[http://tuhdo.github.io/helm-intro.html][this essay on Helm]].

** Grep for my Notes

   I have a voluminous amount of org-mode text files I routinely need
   search and filter.

   I use the standard [[http://emacswiki.org/emacs/GrepMode#toc1][grep package]] in Emacs, but need a later
   version of Gnu Grep. On Mac OS X, run these two commands:

   #+BEGIN_SRC sh
     brew tap homebrew/dupes
     brew install homebrew/dupes/grep
   #+END_SRC

*** Silver Searcher

    With [[https://twitter.com/_wilfredh][Wilfred Hughes]]' fancy [[https://github.com/Wilfred/ag.el/#agel][ag package]], I‚Äôve switch from [[http://beyondgrep.com][ack]] to the
    [[http://geoff.greer.fm/2011/12/27/the-silver-searcher-better-than-ack/][Silver Searcher]]:

    #+BEGIN_SRC sh
      brew install ag
    #+END_SRC

    Best part about the ag package, is not needing any configuration
    (as all functions are load-on demand).

    - =ag-project-at-point= :: sets the query with the word at point, use: =C-c p s s=
    - =ag-regexp= :: searches for regular expressions in a chosen
                     directory (*Note:* the =ag= command prompts with
                     =regexp=, but it adds a =--literal= option to the command)
    - =C-u= :: Adding a prefix adds command line options, like =-s= or
               =-i= to specify case-sensitivity.

    Create collection of [[file:~/.agignore][ignorable files]] so it doesn‚Äôt look in backup files:

    #+BEGIN_SRC org :tangle ~/.agignore
      #.*
    #+END_SRC

    Using the latest version of =ag=? Highlight the keywords:

    #+BEGIN_SRC elisp
      (use-package ag
        :ensure    t
        :commands  ag
        :init      (setq ag-highlight-search t)
        :config    (add-to-list 'ag-arguments "--word-regexp"))
    #+END_SRC

    Personally, I‚Äôm almost /always/ looking for full words:

*** Spotlight

    However, I also need a global /indexing/ approach to searching
    through my notes, and since I'm usually on a Mac, I might as well
    use the /Spotlight/ service that is already running:

    #+BEGIN_SRC elisp
      (setq locate-command "mdfind")  ;; Use Mac OS X's Spotlight
      (global-set-key (kbd "C-c f l") 'locate)
    #+END_SRC

    The following function wraps =locate-with-filter= to only grab
    =org-mode= files:

    #+BEGIN_SRC elisp
      (defun locate-org-files (search-string)
        (interactive "sSearch string: ")
        (locate-with-filter search-string ".org$"))

      (global-set-key (kbd "C-c f o") 'locate-org-files)
    #+END_SRC

    We /could/ limit the location that Spotlight request searches:

    #+BEGIN_SRC elisp :tangle no
      (defun locate-my-org-files (search-string)
        (let ((tech (concat (getenv "HOME") "/technical"))
              (pers (concat (getenv "HOME") "/personal"))
              (note (concat (getenv "HOME") "/notes"))
              (jrnl (concat (getenv "HOME") "/journal")))
          (-flatten (list "mdfind"
                   (if (file-exists-p tech) (list "-onlyin" tech))
                   (if (file-exists-p pers) (list "-onlyin" pers))
                   (if (file-exists-p note) (list "-onlyin" note))
                   (if (file-exists-p jrnl) (list "-onlyin" jrnl))
                   "-interpret" search-string))))

      (setq locate-make-command-line 'locate-my-org-files)
    #+END_SRC

    However, the problem with locate, is it doesn't show me any
    context. My [[file:bin/find-notes][find-notes]] script uses both =mdfind= and =grep= to both
    better search and display some useful context.

    Just need to wrap that in a function:

    #+BEGIN_SRC elisp
      (defun find-notes (words)
        "Uses my 'find-notes' shell script as a better grep
      utility. Not only does it show the results in a clickable list,
      it also highlights the result, allowing us to put more context in
      the output."
        (interactive "sSearch for words:")
        (let ((program (concat (getenv "HOME") "/bin/find-notes"))
              (buffer-name (concat "*find-notes: " words "*")))
          (call-process program nil buffer-name t words)
          (switch-to-buffer buffer-name)
          (read-only-mode 1)
          (grep-mode)
          (toggle-truncate-lines)
          (beginning-of-buffer)
          (dolist (word (split-string words))
            (highlight-regexp word))))

      (global-set-key (kbd "C-x C-n") 'find-notes)
      (global-set-key (kbd "C-c f n") 'find-notes)
    #+END_SRC

** Recent File List

   According to [[http://www.emacswiki.org/emacs-es/RecentFiles][this article]], Emacs already has the recent file
   listing available, just not turned on.

   #+BEGIN_SRC elisp
     (use-package recentf
       :init
       (setq recentf-max-menu-items 25
             recentf-auto-cleanup 'never
             recentf-keep '(file-remote-p file-readable-p))
       (recentf-mode 1)
       (delete-file "~/.emacs.d/ido.last")
       :bind ("C-c f f" . recentf-open-files))
   #+END_SRC

   We do not want to stat all the files when Emacs starts up because
   files read by Tramp will slow down the start time.

** Backup Settings

   This setting moves all backup files to a central location.
   Got it from [[http://whattheemacsd.com/init.el-02.html][this page]].

   #+BEGIN_SRC elisp
     (setq backup-directory-alist
           `(("." . ,(expand-file-name
                      (ha/emacs-subdirectory "backups")))))
   #+END_SRC

   Make backups of files, even when they're in version control

   #+BEGIN_SRC elisp
     (setq vc-make-backup-files t)
   #+END_SRC

   And let‚Äôs make sure our files are saved if we wander off and
   defocus the Emacs application:

   #+BEGIN_SRC elisp
     (defun save-all ()
       "Saves all dirty buffers without asking for confirmation."
       (interactive)
       (save-some-buffers t))

     (add-hook 'focus-out-hook 'save-all)
   #+END_SRC

* Word Smithing
** Auto Insertion

   Just beginning to get a collection of templates to automatically
   insert if a blank file is loaded.

   #+BEGIN_SRC elisp
     (use-package autoinsert
       :init
       (setq auto-insert-directory (ha/emacs-subdirectory "templates/"))
       ;; Don't want to be prompted before insertion:
       (setq auto-insert-query nil)

       (add-hook 'find-file-hook 'auto-insert)
       (auto-insert-mode 1))
   #+END_SRC

   Add a =:config= section to configure static insertion, and add:

   #+BEGIN_SRC elisp :tangle no
     (define-auto-insert "\\.html?$" "default-html.html")
   #+END_SRC

   However, auto insertion requires entering data for particular fields,
   and for that Yasnippet is better, so in this case, we combine them:

   #+BEGIN_SRC elisp
     (defun ha/autoinsert-yas-expand()
       "Replace text in yasnippet template."
       (yas-expand-snippet (buffer-string) (point-min) (point-max)))
   #+END_SRC

   Now bind many of the templates for auto-insert and field expansion:

   #+BEGIN_SRC elisp
     (use-package autoinsert
       :config
       (define-auto-insert "\\.el$" ["default-lisp.el" ha/autoinsert-yas-expand])
       (define-auto-insert "\\.sh$" ["default-sh.sh" ha/autoinsert-yas-expand])
       (define-auto-insert "/bin/"  ["default-sh.sh" ha/autoinsert-yas-expand])
       (define-auto-insert "\\.html?$" ["default-html.html" ha/autoinsert-yas-expand]))
   #+END_SRC

** Auto Complete

   Using [[http://company-mode.github.io/][company-mode]] for all my auto completion needs.

   Like [[https://github.com/vspinu/company-math][this idea]] of being able to easily insert math
   symbols based on LaTeX keywords. Start typing a backslash.

   #+BEGIN_SRC elisp
     (use-package company
       :ensure t
       :init
       (add-hook 'after-init-hook 'global-company-mode)
       :config
       (add-to-list 'company-backends 'company-math-symbols-unicode)
       :diminish company-mode)
   #+END_SRC

   Take advantage of idle time by displaying some documentation
   using [[https://www.github.com/expez/company-quickhelp][company-quickhelp]] project.

   #+BEGIN_SRC elisp
     (use-package company-quickhelp
       :ensure t
       :config
       (company-quickhelp-mode 1))
   #+END_SRC

   This also requires [[https://github.com/pitkali/pos-tip/blob/master/pos-tip.el][pos-tip]].

** Yasnippets

   The [[https://github.com/capitaomorte/yasnippet][yasnippet project]] allows me to create snippets of code that
   can be brought into a file, based on the language.

   #+BEGIN_SRC elisp
     (use-package yasnippet
       :ensure t
       :init
       (yas-global-mode 1)
       :config
       (add-to-list 'yas-snippet-dirs (ha/emacs-subdirectory "snippets")))
   #+END_SRC

   *Note:*: the =snippets= directory contains directories for each
   mode, e.g.  =clojure-mode= and =org-mode=.

** Spelling Correction with Abbreviation Mode

   According to [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][this discussion]], we can correct a misspelled word
   with =C-x C-i= and it will use the abbreviation mode to
   automatically correct that word...as long as you misspell it the
   same way each time.

   #+BEGIN_SRC elisp
     (defun ha/ispell-word-then-abbrev (p)
       "Call `ispell-word'. Then create an abbrev for the correction made.
     With prefix P, create local abbrev. Otherwise it will be global."
       (interactive "P")
       (let ((bef (downcase (or (thing-at-point 'word) ""))) aft)
         (call-interactively 'ispell-word)
         (setq aft (downcase (or (thing-at-point 'word) "")))
         (unless (string= aft bef)
           (message "\"%s\" now expands to \"%s\" %sally"
                    bef aft (if p "loc" "glob"))
           (define-abbrev
             (if p global-abbrev-table local-abbrev-table)
             bef aft))))

     (global-set-key (kbd "C-x C-i") 'ha/ispell-word-then-abbrev)
   #+END_SRC

   Need to turn on the mode, but not necessarily show it:

   #+BEGIN_SRC elisp
     (use-package abbrev
       :bind ("C-c T a" . abbrev-mode)
       :init (setq save-abbrevs t)
             (setq-default abbrev-mode t)
       :diminish abbrev-mode)
   #+END_SRC

** Spell Checking

   I like spell checking with [[http://www.emacswiki.org/emacs/FlySpell][FlySpell]], which uses the built-in
   spell-check settings of [[https://www.gnu.org/software/ispell/][ispell]].

   The [[http://aspell.net][ASpell]] project is better supported than ISpell.

   #+BEGIN_SRC sh :tangle no
     brew install aspell
   #+END_SRC

   Start for all text modes (but not for log files):

   #+BEGIN_SRC elisp
     (use-package flyspell
       :ensure t
       :diminish flyspell-mode
       :init
       (add-hook 'prog-mode-hook 'flyspell-prog-mode)

       (dolist (hook '(text-mode-hook org-mode-hook))
         (add-hook hook (lambda () (flyspell-mode 1))))

       (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
         (add-hook hook (lambda () (flyspell-mode -1))))

       :config
       (setq ispell-program-name "/usr/local/bin/aspell"
             ispell-dictionary "american" ; better for aspell
             ispell-extra-args '("--sug-mode=ultra" "--lang=en_US")
             ispell-list-command "--list")

       (add-to-list 'ispell-local-dictionary-alist '(nil
                                                     "[[:alpha:]]"
                                                     "[^[:alpha:]]"
                                                     "['‚Äò‚Äô]"
                                                     t
                                                     ("-d" "en_US")
                                                     nil
                                                     utf-8)))
   #+END_SRC

   ASpell automatically configures a personal dictionary
   at =~/.aspell.en.pws=, so no need to configure that.

* Miscellaneous Settings
** Line Numbers

   Turn =linum-mode= on/off with =Command-K= (see the [[*Macintosh][Macintosh]]
   section above).  However, I turn this on automatically for
   programming modes.

   #+BEGIN_SRC elisp
     (add-hook 'prog-mode-hook 'linum-mode)
   #+END_SRC

   If we make the line numbers a fixed size, then increasing or
   decreasing the font size doesn't truncate the numbers:

   #+BEGIN_SRC elisp
     (defun fix-linum-size ()
       (interactive)
       (set-face-attribute 'linum nil :height 110))

     (add-hook 'linum-mode-hook 'fix-linum-size)
   #+END_SRC

   If we alternate between line numbers and no-line numbers, I also
   have to turn on/off the fringe. Actually, this is really only
   useful when giving presentations.

   #+BEGIN_SRC elisp
     (defun linum-off-mode ()
       "Toggles the line numbers as well as the fringe. This allows me
     to maximize the screen estate."
       (interactive)
       (if linum-mode
           (progn
             (fringe-mode '(0 . 0))
             (linum-mode -1))
         (fringe-mode '(8 . 0))
         (linum-mode 1)))

       (global-set-key (kbd "A-C-K") 'linum-off-mode)
       (global-set-key (kbd "s-C-K") 'linum-off-mode)  ;; For Linux
   #+END_SRC

   I'm intrigued with the [[https://github.com/coldnew/linum-relative][linum-relative]] mode (especially since I can
   toggle between them). The idea is that I can see the line that I
   want to jump to (like one 9 lines away), and then =C-9 C-n= to
   quickly pop to it.

   #+BEGIN_SRC elisp
     (use-package linum-relative
       :ensure t
       :config
       ;; Otherwise, let's take advantage of the relative line numbering:
       (defun linum-new-mode ()
         "If line numbers aren't displayed, then display them.
          Otherwise, toggle between absolute and relative numbers."
         (interactive)
         (if linum-mode
             (linum-relative-toggle)
           (linum-mode 1)))

       :bind ("A-k" . linum-new-mode)
             ("s-k" . linum-new-mode))   ;; For Linux
   #+END_SRC

** Breadcrumbs

   I often flubber my attempts at walking back through the movements
   with those two key sequences. Better to set this variable so that
   repeated =C-SPC= continue to pop back through the ring:

   #+BEGIN_SRC elisp
     (setq set-mark-command-repeat-pop t)
   #+END_SRC

   More than the breadcrumbs left by marking, the [[http://www.emacswiki.org/emacs/GotoChg][goto-chg]] project
   let's me walk back to where I last edited, which is usually more
   accurate:

   #+BEGIN_SRC elisp
     (use-package goto-chg
       :ensure t
       :bind (("M-p" . goto-last-change)
              ("M-n" . goto-last-change-reverse)))
   #+END_SRC

   Use =C-u 0 M-p= shows a description of the change you made at each point.

   However, if walking back through your /historical trail/ crosses
   files, then dropping some phat marks is the correct approach.

   Leave a mark every time I re-center the screen. Then, walk back and
   forth through its history (using the [[https://github.com/pheaver/breadcrumb][breadcrumb]] project):

   #+BEGIN_SRC elisp
     (use-package breadcrumb
       :load-path "~/Other/breadcrumb/"
       :commands bc-set bc-previous bc-next
       :init (defun ha/mark-and-center ()
               "Recenter the display and drops a breadcrumb."
               (interactive)
               (bc-set)
               (recenter-top-bottom))
       :config (unbind-key "A-." mac-key-mode-map)
       :bind (("C-l" . ha/mark-and-center)
              ("A-," . bc-previous)
              ("A-." . bc-next)))
   #+END_SRC

** Smart Comments

   The [[https://github.com/paldepind/smart-comment][smart-comment]] project has the nice feature of commenting a line
   without being at the beginning of the line (default comment in the
   middle of the line is to split it).

   #+BEGIN_SRC elisp
     (use-package smart-comment
       :ensure t
       :bind ("M-;" . smart-comment))
   #+END_SRC

   Also has the ability (with the =C-u= prefix) to mark comments as
   things to be deleted.

** Smart Scan

   Use the =M-n= to search the buffer for the word the cursor is
   currently pointing. =M-p= to go backwards. See [[http://www.masteringemacs.org/articles/2011/01/14/effective-editing-movement/][this essay]] for
   details.

   #+BEGIN_SRC elisp :tangle no
     (use-package smartscan
       :ensure t
       :bind ("M-n" . smartscan-symbol-go-forward)
             ("M-p" . smartscan-symbol-go-backward))
   #+END_SRC

** Strip Whitespace on Save

   When I save, I want to always, and I do mean always strip all
   trailing whitespace from the file.

   #+BEGIN_SRC elisp
     (add-hook 'before-save-hook 'delete-trailing-whitespace)
   #+END_SRC

** Save File Position

   Save the point position for every file, and restore it when that
   file is reloaded.

   #+BEGIN_SRC elisp
     (require 'saveplace)
     (setq-default save-place t)
     (setq save-place-forget-unreadable-files t)
     (setq save-place-skip-check-regexp "\\`/\\(?:cdrom\\|floppy\\|mnt\\|/[0-9]\\|\\(?:[^@/:]*@\\)?[^@/:]*[^@/:.]:\\)")
   #+END_SRC

** Better Searching and Visual Regular Expressions

   Searching is quite good in Emacs. Let's add a few extra keys:

   #+BEGIN_SRC elisp
     (bind-keys :map isearch-mode-map
                ("<left>"  . isearch-repeat-backward)
                ("<right>" . isearch-repeat-forward)
                ("<up>"    . isearch-ring-retreat)
                ("<down>"  . isearch-ring-advance))
   #+END_SRC

   Easier replacement of my [[http://www.masteringemacs.org/articles/2011/01/14/effective-editing-movement/][Smart Scan]] for searching forward/backward
   for the current word. This is now bound to =M-s .= (in Emacs 24.4),
   but I then have to hit =C-s= or =C-r= ... nicer to use the period/comma.

   The [[https://github.com/benma/visual-regexp.el][Visual Regular Expressions]] project highlights the matches
   while you try to remember the differences between Perl's regular
   expressions and Emacs'...

   Begin with =C-c r= then type the regexp. To see the highlighted
   matches, type =C-c a= before you hit 'Return' to accept it.

   #+BEGIN_SRC elisp
     (use-package visual-regexp
       :ensure t
       :init
       (use-package visual-regexp-steroids :ensure t)

       :bind (("C-c r" . vr/replace)
              ("C-c q" . vr/query-replace))

       ;; if you use multiple-cursors, this is for you:
       :config (use-package  multiple-cursors
                 :bind ("C-c m" . vr/mc-mark)))
   #+END_SRC

** Flycheck

   [[https://github.com/flycheck/flycheck][Flycheck]] seems to be quite superior to good ol' Flymake.

   #+BEGIN_SRC elisp
     (use-package flycheck
       :ensure t
       :init
       (add-hook 'after-init-hook 'global-flycheck-mode)
       :config
       (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
   #+END_SRC

** Hungry Delete

   The Hungry Delete project is a [[http://endlessparentheses.com//hungry-delete-mode.html][free feature]], where deleting any
   space, deletes ALL spaces.

   This is already built into Emacs with the following:
   - =M-\= :: Removes all spaces
   - =M-SPC= :: Removes extra spaces, leaving just one
   - =M-^= :: Joins current line with previous line (doesn't matter
        where the point is on the line)
   - =M-- M-1 M-SPC= :: Joins next line to this one (if point at end
        of line) separated by a space ... quite the chording, eh?

** Table and Column Alignment

   While I shouldn't, I like to line up comma-separated columns (and
   colon-delimited hashes), and since I can never type the regular
   expression on the first time, I wrapped it up in a callable
   function.

   #+BEGIN_SRC elisp
     (defun align-comma (start end c)
       "Repeat alignment with a character padded with spaces for
     comma-separated columns."
       (interactive "r\nsAlign character: ")
       (align-regexp start end
                     (concat c "\\(\\s-*\\)") 1 1 t))
   #+END_SRC

* Programming Languages

** General Language Support

   Many programming language environments can benefit from this section.

*** ElDoc

    I like ElDoc support (when I can get it), but not needed in the
    mode line:

    #+BEGIN_SRC elisp
      (use-package eldoc
        :diminish eldoc-mode)
    #+END_SRC

*** Tag Support

   All programming languages require some sort of tagging. but after
   thirty years, we are still using good ol‚Äô ctags...well,
   [[http://ctags.sourceforge.net][Exuberant Ctags]].   Install with Homebrew:

   #+BEGIN_SRC sh :tangle no
     brew install --HEAD ctags
   #+END_SRC

   On Ubuntu Linux, do:

   #+BEGIN_SRC sh :tangle no
     sudo apt-get install -y exuberant-ctags
   #+END_SRC

   Note: for every project, run the following command:

   #+BEGIN_SRC sh :tangle no
     ctags -e -R .
   #+END_SRC

   I want to be able to add headers from my =org-mode= files as
   a /language option/:

   #+BEGIN_SRC sh :tangle ~/.ctags :comments no
    --langdef=org
    --langmap=org:.org
    --regex-org=/^\*+[ \t]+([a-zA-Z0-9_ ]+)/\1/d,definition/
   #+END_SRC

   We access stuff by loading the =etags= package:

   #+BEGIN_SRC elisp
     (require 'etags)
   #+END_SRC

   Now, use the following keys:

   - M-. :: To find the tag at point to jump to the function‚Äôs
            definition when the point is over a function call. It is a
            dwim-type function.
   - M-, :: jump back to where you were.
   - M-? :: find a tag, that is, use the Tags file to look up a
            definition. If there are multiple tags in the project with
            the same name, use `C-u M-.‚Äô to go to the next match.
   - =M-x tags-search= :: regexp-search through the source files
        indexed by a tags file (a bit like =grep=)
   - =M-x tags-query-replace= :: query-replace through the source files
        indexed by a tags file
   - =M-x tags-apropos= :: list all tags in a tags file that match a
        regexp
   - =M-x list-tags= :: list all tags defined in a source file

   With the fancy new [[https://marmalade-repo.org/packages/ctags-update][ctags-update]] package, we can update the tags file
   whenever we save a file:

   #+BEGIN_SRC elisp
     (use-package ctags-update
       :ensure t
       :config
       (add-hook 'prog-mode-hook  'turn-on-ctags-auto-update-mode)
       :diminish ctags-auto-update-mode)
   #+END_SRC

   While, I like =imenu=, [[https://github.com/vspinu/imenu-anywhere][combining it]] with an IDO interface nicely
   lists the headings/functions in the current buffer:

   #+BEGIN_SRC elisp
     (use-package idomenu
       :ensure t
       :bind ("C-c i" . idomenu))
   #+END_SRC

   And if I'm lazy and willing to use the mouse:

   #+BEGIN_SRC elisp
     (use-package imenu+
       :ensure t
       :init (add-hook 'prog-mode-hook 'imenup-add-defs-to-menubar)
             (add-hook 'org-mode-hook  'imenup-add-defs-to-menubar))
   #+END_SRC

   If I don't know what I'm after, Helm is better:

   #+BEGIN_SRC elisp
     (use-package helm
       :bind (("C-c M-i" . helm-imenu)))
   #+END_SRC

   However, I need to use [[http://www.emacswiki.org/emacs/EtagsSelect#toc3][this function]] to use IDO in conjunctions
   with the TAGS file for all functions in the project:

   #+BEGIN_SRC elisp
     (use-package ido
       :config
       (defun ido-find-tag ()
         "Find a tag using ido"
         (interactive)
         (tags-completion-table)
         (let (tag-names)
           (mapatoms (lambda (x)
                       (push (prin1-to-string x t) tag-names))
                     tags-completion-table)
           (find-tag (ido-completing-read "Tag: " tag-names))))

       (global-set-key (kbd "C-c I") 'ido-find-tag))
   #+END_SRC

   Emacs 25 changed has now deprecated the famous [[info:emacs#Tags][Tags and Friends]],
   like =find-tags= for =xref=. Some point, I will have to learn how
   to configure it, but until then, I'll just rebind to my old mates:

   #+BEGIN_SRC elisp :tangle no
     (global-set-key (kbd "M-.") 'find-tag)
     (global-set-key (kbd "C-M-.") 'find-tag-regexp)
     (global-set-key (kbd "M-,") 'pop-tag-mark)
     (global-set-key (kbd "M-i") 'imenu-anywhere)
   #+END_SRC

   Note: This prompt needs to go away:

   #+BEGIN_SRC elisp
     (setq tags-add-tables nil)
   #+END_SRC

*** Code Block Folding

    The [[info:emacs#Hideshow][Hide Show Minor]] mode allows us to /fold/ all functions
    (hidden), showing only the header lines. We need to turn on the
    mode, so wrappers are in order:

    #+BEGIN_SRC elisp
      (defun ha/hs-show-all ()
        (interactive)
        (hs-minor-mode 1)
        (hs-show-all))

      (defun ha/hs-hide-all ()
        (interactive)
        (hs-minor-mode 1)
        (hs-hide-all))

      (defun ha/hs-toggle-hiding ()
        (interactive)
        (hs-minor-mode 1)
        (hs-toggle-hiding))
    #+END_SRC

    Seems that =C-c @= is too obnoxious to use, so I'll put my
    favorite on the =C-c h= prefix:

    #+BEGIN_SRC elisp
      (use-package hs-minor-mode
        :bind
        ("C-c T h" . hs-minor-mode)
        ("C-c h a" . ha/hs-hide-all)
        ("C-c h s" . ha/hs-show-all)
        ("C-c h h" . ha/hs-toggle-hiding))
    #+END_SRC

    See the [[http://www.emacswiki.org/emacs/HideShow][online resources]].

*** Aggressive Auto Indention

    Automatically indent without use of the tab found in [[http://endlessparentheses.com/permanent-auto-indentation.html][this article]],
    and seems to be quite helpful for many types of programming
    languages.

    To begin, we create a function that can indent a function by
    calling =indent-region= on the beginning and ending points of a
    function.

    #+BEGIN_SRC elisp
      (defun indent-defun ()
        "Indent current defun.
      Do nothing if mark is active (to avoid deactivaing it), or if
      buffer is not modified (to avoid creating accidental
      modifications)."
        (interactive)
        (unless (or (region-active-p)
                    buffer-read-only
                    (null (buffer-modified-p)))
          (let ((l (save-excursion (beginning-of-defun 1) (point)))
                (r (save-excursion (end-of-defun 1) (point))))
            (cl-letf (((symbol-function 'message) #'ignore))
              (indent-region l r)))))
    #+END_SRC

    Next, create a hook that will call the =indent-defun= with every
    command call:

    #+BEGIN_SRC elisp
      (defun activate-aggressive-indent ()
        "Locally add `ha/indent-defun' to `post-command-hook'."
        (add-hook 'post-command-hook
                  'indent-defun nil 'local))
    #+END_SRC

*** Red Warnings

    Various keywords (in comments) are now flagged in a Red Error font:

    #+BEGIN_SRC elisp
      (add-hook 'prog-common-hook
                (lambda ()
                  (font-lock-add-keywords nil
                                          '(("\\<\\(FIX\\|FIXME\\|TODO\\|BUG\\|HACK\\):" 1 font-lock-warning-face t)))))
    #+END_SRC

** Shell Scripts

   Files in my =bin= directory (but /only/ if it doesn't have any
   other extension), should start in =sh-mode=:

   #+BEGIN_SRC elisp
     (add-to-list 'auto-mode-alist '("/bin/" . sh-mode))
   #+END_SRC

** Emacs Lisp

   Sure, everything here is in Emacs Lisp, but this section helps me
   write more of that... like making snazzy symbols and colorizing the
   variables.

   The [[https://github.com/ankurdave/color-identifiers-mode][color-identifiers]] project (unlike [[https://github.com/Fanael/rainbow-identifiers][others]]), downplay the
   keywords, and increase the colorizing of the variables.

   #+BEGIN_SRC elisp
     (use-package color-identifiers-mode
       :ensure t
       :init
         (add-hook 'emacs-lisp-mode-hook 'color-identifiers-mode)
       :diminish color-identifiers-mode)
   #+END_SRC

   The only real snazzy symbol that I like is replacing the =lambda=
   with Œª:

   #+BEGIN_SRC elisp
     (use-package lisp-mode
       :init
       (defconst lisp--prettify-symbols-alist
         '(("lambda"  . ?Œª)
           ("."       . ?‚Ä¢)))
       :config
       (add-hook 'emacs-lisp-mode-hook 'global-prettify-symbols-mode)
       (add-hook 'emacs-lisp-mode-hook 'activate-aggressive-indent))
   #+END_SRC

*** Paredit

    One of the cooler features of Emacs is the [[http://emacswiki.org/emacs/ParEdit][ParEdit mode]] which
    keeps all parenthesis balanced in Lisp-oriented languages.
    See this [[http://www.emacswiki.org/emacs/PareditCheatsheet][cheatsheet]].

    #+BEGIN_SRC elisp
      (use-package paredit
        :ensure t
        :diminish paredit-mode
        :init
          (add-hook 'emacs-lisp-mode-hook 'paredit-mode))
    #+END_SRC

*** Colored Variables

    Color each variable, and downplay standard key words:

    #+BEGIN_SRC elisp
      (use-package color-identifiers-mode
        :ensure t
        :init
        (add-hook 'emacs-lisp-mode-hook 'color-identifiers-mode))
    #+END_SRC

*** Nicer Paren Matching

    The reverse mode of the default parenthesis matching doesn‚Äôt match
    as well, so [[http://www.emacswiki.org/emacs/ShowParenMode][this code]] just makes it bold and more obvious:

    #+BEGIN_SRC elisp
      (use-package paren
        :init
        (set-face-background 'show-paren-match (face-background 'default))
        (set-face-foreground 'show-paren-match "#afa")
        (set-face-attribute  'show-paren-match nil :weight 'black)
        (set-face-background 'show-paren-mismatch (face-background 'default))
        (set-face-foreground 'show-paren-mismatch "#c66")
        (set-face-attribute  'show-paren-mismatch nil :weight 'black))
    #+END_SRC

    While we are at it, let's dim the parens:

    #+BEGIN_SRC elisp
      (use-package paren-face
        :ensure t
        :init
        (global-paren-face-mode))
    #+END_SRC

*** Insert Comment of Eval

    While writing and documenting Emacs Lisp code, it would be helpful
    to insert the results of evaluation of an s-expression directly
    into the code as a comment:

    #+BEGIN_SRC elisp
      (use-package lisp-mode
        :config (defun eval-and-comment-output ()
                  "Add the output of the sexp as a comment after the sexp"
                  (interactive)
                  (save-excursion
                    (end-of-line)
                    (condition-case nil
                        (princ (concat " ; -> " (pp-to-string (eval (preceding-sexp))))
                               (current-buffer))
                      (error (message "Invalid expression")))))

        :bind ("C-x e" . eval-and-comment-output))
    #+END_SRC

** Clojure

   See [[file:emacs-clojure.org][emacs-clojure.el]] for details on working with [[http://clojure.org][Clojure]].
   Not sure if I should just load it directly, like:

   #+BEGIN_SRC elisp :tangle no
     (require 'init-clojure)
   #+END_SRC

** Java

   As soon as a I have a project that requires Java (and doesn‚Äôt allow
   me to work on either Clojure or Scala, I‚Äôll update my old Java
   initialization section.

   #+BEGIN_SRC elisp
     (defun my-c-mode-hook ()
       (setq c-basic-offset 4)
       (c-set-offset 'substatement-open 0)   ; Curly braces alignment
       (c-set-offset 'case-label 4))         ; Switch case statements alignment

     (add-hook 'c-mode-hook 'my-c-mode-hook)
     (add-hook 'java-mode-hook 'my-c-mode-hook)
   #+END_SRC

** Ruby

   See my [[file:emacs-ruby.org][emacs-ruby.el]] file for details on working with Ruby.
   Typically, my [[file:emacs-local.org][emacs-local.el]] file would do the work of requiring
   this for particular hosts or projects.

   #+BEGIN_SRC elisp :tangle no
     (require 'init-ruby)
   #+END_SRC

** Python

   See [[file:emacs-python.org][emacs-python.el]] for details on working with Python.
   Not sure if I should just load it directly, like:

   #+BEGIN_SRC elisp :tangle no
     (require 'init-python)
   #+END_SRC

** JavaScript

   See [[file:emacs-javascript.org][emacs-javascript.el]] for details on working with JavaScript.

   #+BEGIN_SRC elisp :tangle no
     (require 'init-javascript)
   #+END_SRC

** HTML, CSS and other Web Programming

   See [[file:emacs-web.org][emacs-web.el]] for details on working with HTML and its ilk.

   #+BEGIN_SRC elisp :tangle no
     (require 'init-web)
   #+END_SRC

* Org-Mode

  See [[file:emacs-org.org][emacs-org-mode.el]] for details on my [[http://www.orgmode][Org-Mode]] settings.

  #+BEGIN_SRC elisp
    (require 'init-org-mode)
  #+END_SRC

* Tools
** Git

   I like [[https://github.com/syohex/emacs-git-gutter-fringe][git-gutter-fringe]]:

   #+BEGIN_SRC elisp
     (use-package git-gutter-fringe
        :ensure t
        :config (git-gutter-mode 1))
   #+END_SRC

   I want to have special mode for Git's =configuration= file:

   #+BEGIN_SRC elisp
     (use-package gitconfig-mode
       :ensure t)

     (use-package gitignore-mode
       :ensure t)
   #+END_SRC

   What about being able to see the [[https://github.com/voins/mo-git-blame][Git blame]] in a buffer?

   #+BEGIN_SRC elisp
     (use-package mo-git-blame
        :ensure t)
   #+END_SRC

   Run =mo-git-blame-current= to see the goodies.

** Magit

   Git is [[http://emacswiki.org/emacs/Git][already part of Emacs]]. However, [[http://philjackson.github.com/magit/magit.html][Magit]] is sweet.
   Don't believe me? Check out [[https://www.youtube.com/watch?v=vQO7F2Q9DwA][this video]].

   #+BEGIN_SRC elisp
     (use-package magit
       :ensure t
       :commands magit-status magit-blame
       :init
       (defadvice magit-status (around magit-fullscreen activate)
         (window-configuration-to-register :magit-fullscreen)
         ad-do-it
         (delete-other-windows))
       :config
       (setq magit-branch-arguments nil
             ;; use ido to look for branches
             magit-completing-read-function 'magit-ido-completing-read
             ;; don't put "origin-" in front of new branch names by default
             magit-default-tracking-name-function 'magit-default-tracking-name-branch-only
             magit-push-always-verify nil
             ;; Get rid of the previous advice to go into fullscreen
             magit-restore-window-configuration t)

       :bind ("C-x g" . magit-status))
   #+END_SRC

   I like having Magit to run in a /full screen/ mode, and add the
   above =defadvice= idea from [[https://github.com/magnars/.emacs.d/blob/master/setup-magit.el][Sven Magnars]].

** Markdown

   Don't use Markdown nearly as much as I used to, but I'm surprised
   that the following extension-associations aren't the default:

   #+BEGIN_SRC elisp
     (use-package markdown-mode
       :ensure t
       :mode ("\\.\\(m\\(ark\\)?down\\|md\\)$" . markdown-mode)
       :config
       (bind-key "A-b" (surround-text-with "+*") markdown-mode-map)
       (bind-key "s-b" (surround-text-with "**") markdown-mode-map)
       (bind-key "A-i" (surround-text-with "*") markdown-mode-map)
       (bind-key "s-i" (surround-text-with "*") markdown-mode-map)
       (bind-key "A-=" (surround-text-with "`") markdown-mode-map)
       (bind-key "s-=" (surround-text-with "`") markdown-mode-map))
   #+END_SRC

** PlantUML and Graphviz

   Install the [[http://www.graphviz.org/][Graphviz]] and [[http://plantuml.sourceforge.net/download.html][PlantUML]] projects using Homebrew:

   #+BEGIN_SRC sh :tangle no
     brew install graphviz
     brew link graphviz
     brew install plantuml
   #+END_SRC

   Load the [[https://github.com/wildsoul/plantuml-mode][mode for PlantUML]] and reference its jar:

   #+BEGIN_SRC elisp
     (let ((plantuml-jar (car (file-expand-wildcards "/usr/local/Cellar/plantuml/*/plantuml*.jar"))))
       (if plantuml-jar
           (use-package plantuml-mode
             :ensure t
             :init
             (setq plantuml-jar-path     plantuml-jar
                   org-plantuml-jar-path plantuml-jar))))
   #+END_SRC

   And the [[http://ppareit.github.com/graphviz-dot-mode/][mode for Graphviz]]:

   #+BEGIN_SRC elisp
     (use-package graphviz-dot-mode
        :ensure t)
   #+END_SRC

* Applications
** Web Browsing

   This section became involved, and has moved on to [[file:emacs-browser.org][emacs-browser]]
   file.

   #+BEGIN_SRC elisp
     (require 'init-browser)
   #+END_SRC

** EShell

   See [[file:emacs-eshell.org][emacs-eshell.el]] for details of configuring and using EShell.

   #+BEGIN_SRC elisp
     (require 'init-eshell)
   #+END_SRC

** Chatting

   Using the [[http://www.emacswiki.org/emacs/JabberEl][jabber.el]] project to connect up to Google Talk and what
   not. To begin, make sure you =brew install gnutls=

   #+BEGIN_SRC elisp
     (use-package jabber
       :ensure t
       :commands jabber-connect-all jabber-chat-with
       :init
       (define-key personal-global-map (kbd "a") 'jabber-connect-all)
       (define-key personal-global-map (kbd "j") 'jabber-chat-with)
       :config
       (setq starttls-use-gnutls t
             starttls-gnutls-program "gnutls-cli"
             starttls-extra-arguments '("--starttls" "--insecure")

             jabber-history-enabled t
             jabber-use-global-history nil
             jabber-backlog-number 40
             jabber-backlog-days 30)

       (defun my-jabber-chat-delete-or-bury ()
         (interactive)
         (if (eq 'jabber-chat-mode major-mode)
             (condition-case e
                 (delete-frame)
               (error
                (if (string= "Attempt to delete the sole visible or iconified frame"
                             (cadr e))
                    (bury-buffer))))))

       (define-key jabber-chat-mode-map [escape] 'my-jabber-chat-delete-or-bury))
   #+END_SRC

* Technical Artifacts

** Setting up the Exec Path

   Make sure that =PATH= variable for finding binary files can is the
   same as what Emacs will look for binary files. This little magic,
   starts up a shell, gets its path, and then uses that for the
   =exec-path=:

   #+BEGIN_SRC elisp
     (when window-system
       (let ((path-from-shell (shell-command-to-string "/bin/bash -l -c 'echo $PATH'")))
         (setenv "PATH" path-from-shell)
         (setq exec-path (split-string path-from-shell path-separator))))
   #+END_SRC

** Configure the Graphical Settings

   If we are running in a windowed environment where we can set up
   fonts and whatnot, call the 'mac' stuff... which will still work
   for Linux too.

   #+BEGIN_SRC elisp
     (if (window-system)
        (require 'init-client)
      (require 'init-server))
   #+END_SRC

** Load up the Local Configuration

   Before we finish, we need to check if there is a local file for us
   to load and evaluate.  We assume the local file has been tangled
   and provides the =init-local= key:

   #+BEGIN_SRC elisp
     (require 'init-local nil t)
   #+END_SRC

   After the first load, we can reload this with a require:

   #+BEGIN_SRC elisp
     (provide 'init-main)
   #+END_SRC

   Before you can build this on a new system, make sure that you put
   the cursor over any of these properties, and hit: =C-c C-c=

#+DESCRIPTION: A literate programming version of my Emacs Initialization script, loaded by the .emacs file.
#+PROPERTY:    results silent
#+PROPERTY:    header-args:sh  :tangle no
#+PROPERTY:    tangle ~/.emacs.d/elisp/init-main.el
#+PROPERTY:    eval no-export
#+PROPERTY:    comments org
#+OPTIONS:     num:nil toc:nil todo:nil tasks:nil tags:nil
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
