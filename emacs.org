#+TITLE:  Emacs Configuration File
#+AUTHOR: Howard Abrams
#+EMAIL:  howard.abrams@gmail.com

This is my =.emacs= file, written using [[http://www.orgmode.org][org-mode]], so that I can
organize it and take notes on all the complexity.

  - The =tab= key opens/close a particular section
  - Shift + =tab= cycles between the outline and full text
  - Render it with:  =C-c C-v t=
  - Creates a file:  =~/.emacs-ext.el=
  - Load it during from the =.emacs= file, like:

#+BEGIN_EXAMPLE
  ;; Load our Literate Programming version of our Dot Emacs
  ;; file, from file: ~/Dropbox/emacs.d/dot-emacs.org
  (load-file "~/.emacs-ext.el")
#+END_EXAMPLE

* Introduction

  This file is really a /script/ that generates my Emacs configuration
  file. For all of this to work, you need version 24 (or at least,
  version 23, like [[http://aquamacs.org/][Aquamacs]]). Pick [[https://github.com/railwaycat/emacs-mac-port][Yamamoto Mitsuharu's version]]!

#+BEGIN_HTML
  <p>
    You can download the <a href="dot-emacs.org">original org-mode
    file</a> or view the <a href="dot-emacs.el">tangled end results</a>.
  </p>
#+END_HTML

  We begin this initialization script with a warning not to edit the
  generated file:

#+NAME: Note
#+BEGIN_SRC elisp :comments off
  ;;; ------------------------------------------
  ;;; Do not edit the generated file, as it has
  ;;; been generated, as a tangled file, by the
  ;;; fandifluous org-mode.
  ;;;
  ;;; Source: ~/Dropbox/dot-files/emacs.org
  ;;; ------------------------------------------
#+END_SRC

** Initializing a New Emacs

   Emacs already comes bundled to edit most files, like Java and Ruby.
   However, some of the new stuff that I use isn't bundled, yet.

   Before this startup file can run, we need to initialize a clean
   Emacs instance by: =load-file ~/.emacs.d/init.el=
   This file is created by [[file:emacs-init.org][emacs-init.org]].

* General Settings

** Extra Packages

   Extra packages not available via the package manager go in my
   personal stash at: =$HOME/.emacs.d=

#+BEGIN_SRC elisp
  (add-to-list 'load-path "~/.emacs.d/")
#+END_SRC

** Package Manager

   Emacs has become like every other operating system, and now has a
   [[http://tromey.com/elpa/][package manager]] with its own collection of repositories. Of
   course, now, instead of trying to figure out and maintain
   packages, we have to keep track of what packages live on what
   repos. This is [[http://batsov.com/articles/2012/02/19/package-management-in-emacs-the-good-the-bad-and-the-ugly/][an improvement]].

   *NB:* We want to add the [[http://marmalade-repo.org/][Marmalade repository]].

#+BEGIN_SRC elisp
  ; (load "~/.emacs.d/elpa/package.el") Needed for version 23 only!
  (require 'package)

  (setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                           ("gnu"       . "http://elpa.gnu.org/packages/")
                           ("melpa"     . "http://melpa.milkbox.net/packages/")
                           ("tromey"    . "http://tromey.com/elpa/")
                           ("marmalade" . "http://marmalade-repo.org/packages/")))
#+END_SRC

   While we can now do a =package-list-packages=, you can install and
   everything is good, however, we can't =require= any of these
   packages (in order to customize them in this file) until we do
   this:

#+BEGIN_SRC elisp
  (package-initialize)
#+END_SRC

** Package Loading

   The =(require)= is a problem if the library isn't available, and if
   it isn't available, then this file dies and doesn't complete.
   Seems like it would be nice to wrap the configuration of a package
   in a block that is ignored if the package isn't available.

   This is what I found [[http://stackoverflow.com/questions/7790382/how-to-determine-whether-a-package-is-installed-in-elisp][in this discussion]].

#+BEGIN_SRC elisp
  (defun autofeaturep (feature)
    "For a feature symbol 'foo, return a result equivalent to:
  (or (featurep 'foo-autoloads) (featurep 'foo))
  Does not support subfeatures."
    (catch 'result
      (let ((feature-name (symbol-name feature)))
        (unless (string-match "-autoloads$" feature-name)
          (let ((feature-autoloads (intern-soft (concat feature-name "-autoloads"))))
            (when (and feature-autoloads (featurep feature-autoloads))
              (throw 'result t))))
        (featurep feature))))
#+END_SRC
** Variables

   General settings about me that other packages can use. The biggest
   problem is guessing my email address based on what computer I am using:

#+BEGIN_SRC elisp
  (if (equal "howard.abrams" user-login-name)
      (setq user-mail-address "howard.abrams@workday.com")
    (setq user-mail-address "howard.abrams@gmail.com"))
#+END_SRC

*** Tabs vs Spaces

   I have learned to distrust tabs in my source code, so let's make
   sure that we only have spaces.

#+BEGIN_SRC elisp
  (setq-default indent-tabs-mode nil)
  (setq tab-width 2)
#+END_SRC

** Font Settings

   I love syntax highlighting.

#+BEGIN_SRC elisp
  (global-font-lock-mode 1)
#+END_SRC

   Specify the default font as =Source Code Pro=, which should already
   be [[http://blogs.adobe.com/typblography/2012/09/source-code-pro.html][downloaded]] and installed.

#+BEGIN_SRC elisp
  (set-default-font "Source Code Pro")
  (set-face-attribute 'default nil :font "Source Code Pro" :height 140)
  (set-face-font 'default "Source Code Pro")
#+END_SRC

   While I do like the =Anonymous Pro= font (and usually have it download and
   installed), I don't like it as much.

#+BEGIN_SRC elisp :tangle no
  (set-default-font "Anonymous Pro")
  (set-face-attribute 'default nil :font "Anonymous Pro" :height 140)
  (set-face-font 'default "Anonymous Pro")
#+END_SRC

** Line Numbers

   Do you want line numbers on the left side:

#+BEGIN_SRC elisp
  (line-number-mode 1)
#+END_SRC

** Color Theme

   We use the color theme project and followed [[http://www.nongnu.org/color-theme/][these instructions]].
   We now can do =M-x color-theme-<TAB> RET=

#+BEGIN_SRC elisp
  (require 'color-theme)
#+END_SRC

   The color themes work quite well, except they don't know about the
   org-mode source code blocks, so we need to set up a couple
   functions that we can use to set them.

#+BEGIN_SRC elisp
  (defun org-src-color-blocks-light ()
    "Colors the block headers and footers to make them stand out more for lighter themes"
    (interactive)
    (custom-set-faces
     '(org-block-begin-line 
      ((t (:underline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF"))))
     '(org-block-background
       ((t (:background "#FFFFEA"))))
     '(org-block-end-line
       ((t (:overline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))))

     ;; Looks like the minibuffer issues are only for v23
     ; (set-face-foreground 'minibuffer "black")
     ; (set-face-foreground 'minibuffer-prompt "red")
  )
  
  (defun org-src-color-blocks-dark ()
    "Colors the block headers and footers to make them stand out more for dark themes"
    (interactive)
    (custom-set-faces
     '(org-block-begin-line 
       ((t (:foreground "#008ED1" :background "#002E41"))))
     '(org-block-background
       ((t (:background "#111111"))))
     '(org-block-end-line
       ((t (:foreground "#008ED1" :background "#002E41")))))
  
     ;; Looks like the minibuffer issues are only for v23
     ; (set-face-foreground 'minibuffer "white")
     ; (set-face-foreground 'minibuffer-prompt "white")
  )
#+END_SRC

   My main reason for wanting to use the color theme project is to
   switch between /black on white/ during the day, and /white on
   black/ at night.

#+BEGIN_SRC elisp
  (defun color-theme-my-default ()
    "Tries to set up a normal color scheme"
    (interactive)
    (color-theme-sanityinc-tomorrow-day)
    (org-src-color-blocks-light))
  
  ;; During the day, we use the "standard" theme:
  (global-set-key (kbd "<f9> d") 'color-theme-my-default)
  
  ;; A good late-night scheme that isn't too harsh
  (global-set-key (kbd "<f9> l") (lambda () (interactive)
                                   (color-theme-sanityinc-tomorrow-eighties)
                                   (org-src-color-blocks-dark)))
  
  ;; Programming late into the night
  (global-set-key (kbd "<f9> m") (lambda () (interactive)
                                   (color-theme-sanityinc-tomorrow-bright)
                                   (org-src-color-blocks-dark)))
  
  ;; Too harsh? Use the late night theme
  (global-set-key (kbd "<f9> n") (lambda () (interactive)
                                   (color-theme-sanityinc-tomorrow-night)
                                   (org-src-color-blocks-dark)))
#+END_SRC

** Macintosh

   I like the ability to use the Command key to turn a standard Emacs
   into a more Macintosh-specific application. (See [[http://stackoverflow.com/questions/162896/emacs-on-mac-os-x-leopard-key-bindings][these online notes]])

#+BEGIN_SRC elisp
  (when (eq system-type 'darwin)
    (setq mac-option-modifier 'meta)

    ;; Aquamacs-specific code:
    (when (boundp 'aquamacs-version)
      (global-set-key [(alt k)] 'nlinum-mode))
    
    ;; Emacs on Mac specific code:
    (unless (boundp 'aquamacs-version)
      ;; Since I already have Command-V for pasting, I
      ;; don't need Ctrl-V to do that, so disable CUA:
      (cua-mode -1)
      
      (require 'mac-key-mode)
      (mac-key-mode 1)
      
      (define-key mac-key-mode-map [(alt +)] 'text-scale-increase)
      (define-key mac-key-mode-map [(alt _)] 'text-scale-decrease)
      (define-key mac-key-mode-map [(alt l)] 'goto-line)
      (define-key mac-key-mode-map [(alt w)] 'delete-single-window)
      (define-key mac-key-mode-map [(alt m)] 'toggle-meta-key)
      (define-key mac-key-mode-map [(alt k)] 'nlinum-mode)))
#+END_SRC

   I hate the default implementation of Command-M. Now,
   pressing Command-M will toggle whether the Option key is a
   standard Option key or a Meta key:

#+BEGIN_SRC elisp
  (defun toggle-meta-key ()
    "Toggles whether the Mac option key is an option key or a meta key."
    (interactive)
    (if (eq mac-option-modifier 'meta)
        (setq mac-option-modifier nil)
      (setq mac-option-modifier 'meta)))
#+END_SRC

   I would like Command-W to close a frame, but only if it only has a
   single window in it. I found this code on [[http://www.emacswiki.org/emacs/frame-cmds.el][this site]].

#+BEGIN_SRC elisp
  (defun delete-single-window (&optional window)
    "Remove WINDOW from the display.  Default is `selected-window'.
  If WINDOW is the only one in its frame, then `delete-frame' too."
    (interactive)
    (save-current-buffer
      (setq window (or window (selected-window)))
      (select-window window)
      (kill-buffer)
      (if (one-window-p t) 
          (delete-frame) 
          (delete-window (selected-window)))))
#+END_SRC
*** Undo and Redo

    According to [[http://ergoemacs.org/emacs/emacs_best_redo_mode.html][this article]], I get better functionality than the
    =redo+= plugin (which I can't seem to get working well).

#+BEGIN_SRC elisp
  (require 'undo-tree)
  (global-undo-tree-mode 1)
  (defalias 'redo 'undo-tree-redo)

  (define-key mac-key-mode-map [(alt z)] 'undo-tree-undo)
  (define-key mac-key-mode-map [(alt S-z)] 'undo-tree-redo)

  (global-set-key (kbd "C-z") 'undo) ; Zap to character isn't helpful
  (global-set-key (kbd "C-S-z") 'redo)
#+END_SRC

** More Key Definitions

   I like the ability to move the current line up or down by just
   doing =S-M-up= and =S-M-down= (just like in Eclipse):

#+BEGIN_SRC elisp
  (load-library "line-move")
#+END_SRC

** Recent File List

   According to [[http://www.emacswiki.org/emacs-es/RecentFiles][this article]], Emacs already has the recent file
   listing available, just not turned on.

#+BEGIN_SRC elisp
  (require 'recentf)
  (recentf-mode 1)
  (setq recentf-max-menu-items 25)
  (global-set-key (kbd "C-x C-r") 'recentf-open-files)
#+END_SRC

** Project Management

   Let's assume that every git repo was a project, wouldn't it be
   nice to do finds and greps limited to such a project.
   This is what [[https://github.com/bbatsov/projectile][Projectile]] attempts to do (see [[http://wikemacs.org/wiki/Projectile][this wiki page]]).

#+BEGIN_SRC elisp
  (require 'projectile)
  (projectile-global-mode) ;; to enable in all buffers
#+END_SRC

   Useful Keybindings:

   - =[C-c p f]= Find a file in the project.
   - =[C-c p g]= Find text matches in the project

   If indexing gets slow, you can cache the results.

** Auto Complete

   This feature scans the code and suggests completions for what you
   are typing. Useful at times ... annoying at others.

#+BEGIN_SRC elisp
  (require 'auto-complete-config)
  (add-to-list 'ac-dictionary-directories "~/.emacs.d/ac-dict")
  (ac-config-default)
#+END_SRC

   Note that we specify where a dictionary lives for each specific
   language.

** Yas Snippet

   The [[https://github.com/capitaomorte/yasnippet][yasnippet project]] allows me to create snippets of code that
   can be brought into a file, based on the language. 

#+BEGIN_SRC elisp
  (require 'yasnippet)
  (require 'yasnippet-bundle)
#+END_SRC

   We load the standard libraries, but load our *special* library
   first. Note: I also grab this collection of [[https://github.com/swannodette/clojure-snippets][Clojure Snippets]].
   Inside each of these directories should be directories like
   =clojure-mode= and =org-mode=. This tells it where to find
   snippets for the current mode.

#+BEGIN_SRC elisp
  (setq yas/root-directory
        '("~/.emacs.d/snippets"            ;; personal snippets
          "~/.emacs.d/clojure-snippets"))

  (yas/global-mode 1)
  (yas/initialize)

  ;; The following command can be used if we change anything
  (yas/reload-all)
#+END_SRC

** Dash

   The [[http://kapeli.com/][Dash product]] looks interesting, and [[https://github.com/Kapeli/dash-at-point][this project]] allows Emacs
   to open Dash for documentation of anything with a =C-c d= keystroke:

#+BEGIN_SRC elisp
  (autoload 'dash-at-point "dash-at-point"
            "Search the word at point with Dash." t nil)
  (global-set-key (kbd "C-c d") 'dash-at-point)
#+END_SRC

   Note: I checked out the code elsewhere, and created a symlink from
   my =~/.emacs.d= directory to the =dash-as-point.el= file.

** Note Grep

   First, we need to have the =find-grep= ignore =.git= directories
   and search for wholewords:

#+BEGIN_SRC elisp
  (setq grep-find-command 
        "find . -type f '!' -wholename '*/.git/*' -print0 | xargs -0 -e grep -nHPi -e ")
  (setq rep-highlight-matches t)
#+END_SRC
   I use the standard [[http://emacswiki.org/emacs/GrepMode#toc1][grep package]] in Emacs and wrap it so that I
   can easily search through my notes.

#+BEGIN_SRC elisp
  (defun ngrep (reg-exp)
    "Searches the Notes and ORG directory tree for an expression."
    (interactive "sSearch note directories: ")
    (let ((file-ext "*.org *.md *.txt *.markdown")
          (search-dir "~/Notes ~/Technical"))
      (message "Searching in %s" search-dir)
      ;; (grep-compute-defaults)
      (grep-find (concat "grep -nHPir -e " reg-exp " --include '*.org' --include '*.md' " search-dir))))
  
  (global-set-key (kbd "C-x C-n") 'ngrep)
  ;; (global-set-key (kbd "C-x C-r") 'rgrep)
#+END_SRC

   Don't forget that after doing a =C-x C-f= to find a file, you can
   hit another =M-f= to do a find the given directory (and subs).

   Also, you can do a full locate with =C-x C-l=:

#+BEGIN_SRC elisp
  (global-set-key (kbd "C-x C-l") 'locate)
  (setq locate-command "mdfind")  ;; Use Mac OS X's Spotlight
#+END_SRC

** Spell Checking


   I like spell checking with [[http://www.emacswiki.org/emacs/FlySpell][FlySpell]], which uses =ispell=.

   To build a dictionary hash (seems important now), do this:

#+BEGIN_SRC sh :tangle no
  buildhash ~/Dropbox/dictionary-personal.txt /opt/local/lib/english.aff ~/Dropbox/dictionary-personal.txt.hash
#+END_SRC

   Then, we can use it like:

#+BEGIN_SRC elisp
  (setq ispell-personal-dictionary
      (concat (getenv "HOME") "/Dropbox/dictionary-personal.txt"))

  (dolist (hook '(text-mode-hook org-mode-hook))
    (add-hook hook (lambda () (flyspell-mode 1))))
#+END_SRC

   If I find any =text-mode= derived mode that I don't want to
   spell-check, then I need to use the following:

#+BEGIN_SRC elisp :tangle no
  (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
    (add-hook hook (lambda () (flyspell-mode -1))))
#+END_SRC

** Miscellaneous Settings

*** IDO (Interactively DO Things)

    According to [[http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/][Mickey]], IDO is the greatest thing.

#+BEGIN_SRC elisp
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (ido-mode 1)
#+END_SRC

    According to [[https://gist.github.com/rkneufeld/5126926][Ryan Kneufeld]], we could make IDO work
    vertically. Not sure if I like this, but we'll try.

#+BEGIN_SRC elisp
(setq ido-decorations                                                      ; Make ido-mode display vertically
      (quote
       ("\n-> "           ; Opening bracket around prospect list
        ""                ; Closing bracket around prospect list
        "\n   "           ; separator between prospects
        "\n   ..."        ; appears at end of truncated list of prospects
        "["               ; opening bracket around common match string
        "]"               ; closing bracket around common match string
        " [No match]"     ; displayed when there is no match
        " [Matched]"      ; displayed if there is a single match
        " [Not readable]" ; current diretory is not readable
        " [Too big]"      ; directory too big
        " [Confirm]")))   ; confirm creation of new file or buffer
 
(add-hook 'ido-setup-hook                                                  ; Navigate ido-mode vertically
          (lambda ()
            (define-key ido-completion-map [down] 'ido-next-match)
            (define-key ido-completion-map [up] 'ido-prev-match)
            (define-key ido-completion-map (kbd "C-n") 'ido-next-match)
            (define-key ido-completion-map (kbd "C-p") 'ido-prev-match)))
#+END_SRC

    I guess you can call =ido-use-url-at-point= with Markdown to jump
    to the URLs. Perhaps?

*** SMEX

    Built using [[*IDO%20(Interactively%20DO%20Things)][IDO]].

#+BEGIN_SRC elisp :tangle no
  (require 'smex)
  (smex-initialize) ; Can be omitted. This might cause a (minimal) delay

  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)

  ;; This is our old M-x.
  (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
#+END_SRC

*** Backup Settings

    This setting moves all backup files to a central location.
    Got it from [[http://whattheemacsd.com/init.el-02.html][this page]].

#+BEGIN_SRC elisp
  (setq backup-directory-alist
        `(("." . ,(expand-file-name
                   (concat user-emacs-directory "backups")))))
#+END_SRC

   Make backups of files, even when they're in version control

#+BEGIN_SRC elisp
  (setq vc-make-backup-files t)
#+END_SRC

*** Line Numbers

    We can turn =nlinum-mode= on/off with
    =Command-K= (see the [[*Macintosh][Macintosh]] section above).
    However, we can turn this on automatically for certain modes?

#+BEGIN_SRC elisp
  (add-hook 'clojure-mode-hook 'nlinum-mode)
  (add-hook 'emacs-lisp-mode-hook 'nlinum-mode)
  (add-hook 'js2-mode-hook 'nlinum-mode)
#+END_SRC

*** Smart Scan

    Use the =M-n= to search the buffer for the word the cursor is
    currently pointing. =M-p= to go backwards.

#+BEGIN_SRC elisp
  (load-library "smart-scan")
#+END_SRC
* Org Mode

  The [[http://orgmode.org][Org Mode]] feature was a big reason in my recent re-kindling of my
  Emacs love affair.

** Initial Settings

   Initialization of Org Mode by hooking it into YASnippets, which
   should allow me to easily add templates to my files.

#+BEGIN_SRC elisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (yas/minor-mode-on)))
#+END_SRC

*** Load Diary File

    A function to easily load today (and yesterday's) journal entry.

#+BEGIN_SRC elisp
  (defun journal-file-today ()
    "Creates and load a file based on today's date."
    (interactive)
    (let ((daily-name (format-time-string "%Y-%m-%d")))
      (find-file (expand-file-name
                  (concat "~/journal/" daily-name ".org")))))
#+END_SRC

    Since I sometimes (not often) forget to create 

#+BEGIN_SRC elisp
  (defun journal-file-yesterday ()
    "Creates and load a file based on yesterday's date."
    (interactive)
    (let ((daily-name (format-time-string "%Y-%m-%d"
       (time-subtract (current-time) (days-to-time 1)))))
      (find-file (expand-file-name
                  (concat "~/journal/" daily-name ".org")))))
#+END_SRC

*** Org-Mode Sprint Note Files

    At the beginning of each sprint, we need to set this to the new
    sprint file.

#+BEGIN_SRC elisp
  (setq current-sprint "2013-10")
  
  (defun current-sprint-file ()
    (expand-file-name (concat "~/Notes/Sprint-" current-sprint ".org")))
  
  (defun get-current-sprint-file ()
    "Loads up the org-mode note associated with my current sprint."
    (interactive)
    (find-file (current-sprint-file)))
#+END_SRC

*** Recent and Heavily Used Files

    We want both a recently seen files as well, as a top 10. This
    /Top 10/ file list can just be an Org file, right?

#+BEGIN_SRC elisp
  (global-set-key (kbd "C-x C-u") 'get-current-sprint-file)
#+END_SRC

*** Org-Mode Colors

  Before we load =org-mode= proper, we need to set the following
  syntax high-lighting parameters. These are used to help bring out
  the source code during literate programming mode.

  This information came from [[http://orgmode.org/worg/org-contrib/babel/examples/fontify-src-code-blocks.html][these instructions]], however, they tend
  to conflict with the /color-theme/, so we'll turn them off for now.

#+BEGIN_SRC elisp
  (defface org-block-begin-line
    '((t (:underline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))
    "Face used for the line delimiting the begin of source blocks.")
  
  (defface org-block-background
    '((t (:background "#FFFFEA")))
    "Face used for the source block background.")
  
  (defface org-block-end-line
    '((t (:overline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))
    "Face used for the line delimiting the end of source blocks.")
#+END_SRC

** Library Loading

   The standard package manager (and most recent versions of Emacs)
   include =org-mode=, however, I want the latest version that has
   specific features for literate programming.

   Org-mode is installed in the global directory.

#+BEGIN_SRC elisp
  (add-to-list 'load-path "~/.emacs.d/org/lisp")
  (require 'org)
  ; (require 'org-install)
  (require 'ob-tangle)
#+END_SRC

** Global Key Bindings

   The =org-mode= has some useful keybindings that are helpful no
   matter what mode you are using currently.

#+BEGIN_SRC elisp
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c b") 'org-iswitchb)

  (global-set-key (kbd "C-M-|") 'indent-rigidly)
#+END_SRC

** Local Key Bindings

   A couple of short-cut keys to make it easier to edit text.

#+BEGIN_SRC elisp
  (defun org-text-wrapper (txt &optional endtxt)
    "Wraps the region with the text passed in as an argument."
    (if (not (use-region-p))
        (mark-word))
    (save-restriction
      (narrow-to-region (region-beginning) (region-end))
      (goto-char (point-min))
      (insert txt)
      (goto-char (point-max))
      (if endtxt
          (insert endtxt)
        (insert txt))))
  
  (defun org-text-bold () "Wraps the region with asterisks."
    (interactive)
    (org-text-wrapper "*"))
  (defun org-text-italics () "Wraps the region with slashes."
    (interactive)
    (org-text-wrapper "/"))
  (defun org-text-code () "Wraps the region with equal signs."
    (interactive)
    (org-text-wrapper "="))
#+END_SRC

   Now we can associate some keystrokes to the org-mode:

#+BEGIN_SRC elisp
  (add-hook 'org-mode-hook
        (lambda ()
          (local-set-key (kbd "A-b") 'org-text-bold)
          (local-set-key (kbd "A-i") 'org-text-italics)
          (local-set-key (kbd "A-=") 'org-text-code)))
#+END_SRC

   I'm often typing Jira entries that match a particular link pattern.

#+BEGIN_SRC elisp
  (defun jira-link (b e)
    "Wraps the region with an org-mode link."
    (interactive "r")
    (save-restriction
      (narrow-to-region b e)
      (let ((jiraid (buffer-substring (point-min) (point-max))))
        (goto-char (point-min))
        (insert "[[https://jira.workday.com/browse/" jiraid "][")
        (goto-char (point-max))
        (insert "]]"))))
#+END_SRC

** Speed Keys

   If point is at the beginning of a headline or code block in
   org-mode, single keys do fun things. See =org-speed-command-help=
   for details (or hit the ? key at a headline).

#+BEGIN_SRC elisp
  (setq org-use-speed-commands t)
#+END_SRC

** Specify the Org Directories

   I keep all my =org-mode= files in a few directories, and I would
   like them automatically searched when I generate agendas.

#+BEGIN_SRC elisp
(setq org-agenda-files '("~/Dropbox/org/personal" 
                         "~/Google Drive/technical" 
                         "~/Dropbox/org/project"))
#+END_SRC

** MobileOrg

   I use [[http://mobileorg.ncogni.to/doc/getting-started/using-dropbox/][Dropbox with MobileOrg]] in order to read my notes on my iPad.

   The "global" location of my Org files on my local system:

#+BEGIN_SRC elisp
  (setq org-directory "~/Dropbox/org/personal")
#+END_SRC

   Set the name of the file where new notes will be stored

#+BEGIN_SRC elisp
  (setq org-mobile-inbox-for-pull "~/Dropbox/org/flagged.org")
#+END_SRC

   Set to <your Dropbox root directory>/MobileOrg.

#+BEGIN_SRC elisp
  (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
#+END_SRC

   To get this going, we just need to: =M-x org-mobile-push=

** Auto Note Capturing

   Let's say you were in the middle of something, but would like to
   /take a quick note/, but without affecting the file you are
   working on. This is called a "capture", and is bound to the
   following key:

#+BEGIN_SRC elisp
  (global-set-key (kbd "C-c c") 'org-capture)
#+END_SRC

   This will bring up a list of /note capturing templates/:

#+BEGIN_SRC elisp
  (setq org-capture-templates
        '(("n" "Thought or Note" entry (file "~/Technical/general-notes.org")
           "* %i%?\n    %a" :empty-lines 1)
  
          ("r" "Retrospective Status" entry (file+headline (current-sprint-file) "Status/Accomplishments")
           "*** %i%?\n  Linked: %a" :empty-lines 1)
          ("g" "Retrospective Goodness" entry (file+headline (current-sprint-file) "Keep Doing (Good)")
           "*** %i%?" :empty-lines 1)
          ("b" "Retrospective Badness" entry (file+headline (current-sprint-file) "Stop Doing (Bad)")
           "*** %i%?" :empty-lines 1)
          ("i" "Retrospective Improvement" entry (file+headline (current-sprint-file) "Start Doing (Improvements)")
           "*** %i%?" :empty-lines 1)
  
          ("p" "Personal Journal" entry (file+datetree "~/Technical/personal.org")
           "* Projects\n\n  %i%?\n\n  %a" :empty-lines 1)))
  
  ;; General notes go into this file:
  (setq org-default-notes-file "~/Technical/personal.org")
#+END_SRC

   After you have selected the template, you type in your note and hit
   =C-c C-c= to store it in the file listed above.

   Just remember, at some point to hit =C-c C-w= to /refile/ that note
   in the appropriate place.

** Checking Things Off

   When I check off an item as done, sometimes I want to add some
   details about the completion (this is really only helpful when I'm
   consulting). 

   With this setting, each time you turn an entry from a TODO state
   into the DONE state, a line 'CLOSED: [timestamp]' will be inserted
   just after the headline. If you turn the entry back into a TODO
   item through further state cycling, that line will be removed
   again.

#+BEGIN_SRC elisp
  ; (setq org-log-done 'time)
  (setq org-log-done 'note)
#+END_SRC

** Org Publishing

   The brilliance of =org-mode= is the ability to publish your notes
   as HTML files into a web server. See [[http://orgmode.org/worg/org-tutorials/org-publish-html-tutorial.html][these instructions]].

#+BEGIN_SRC elisp
  (require 'org-publish)
  
  (setq org-publish-project-alist  '(
    ("org-notes"
     :base-directory        "~/Dropbox/org/"
     :base-extension        "org"
     :publishing-directory  "~/Sites/"
     :recursive             t
     :publishing-function   org-publish-org-to-html
     :headline-levels       4             ; Just the default for this project.
     :auto-preamble         t
     :auto-sitemap          t             ; Generate sitemap.org automagically...
     :makeindex             t
     :section-numbers       nil
     :table-of-contents     nil
     :style "<link rel=\"stylesheet\" href=\"../css/styles.css\" type=\"text/css\"/><link rel=\"stylesheet\" href=\"css/styles.css\" type=\"text/css\"/> <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\" type=\"text/javascript\"></script> <link href=\"http://ajax.googleapis.com/ajax/libs/jqueryui/1.7.2/themes/smoothness/jquery-ui.css\" type=\"text/css\" rel=\"Stylesheet\" />    <script src=\"https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js\" type=\"text/javascript\"></script> <script =\"text/jacascript\" src=\"js/script.js\"></script>"
     )
  
    ("dot-files"
     :base-directory       "~/Dropbox/dot-files/"
     :base-extension       "org"
     :publishing-directory "~/Dropbox/dot-files/docs"
     :recursive            f
     :publishing-function   org-publish-org-to-html
     :auto-preamble         t
     :auto-sitemap          t             ; Generate sitemap.org automagically...
     :makeindex             f
     :section-numbers       nil
     :table-of-contents     nil
     )

    ("org-static"
     :base-directory       "~/Dropbox/org/"
     :base-extension       "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
     :publishing-directory "~/Sites/"
     :recursive            t
     :publishing-function  org-publish-attachment
     )
  
    ("all" :components ("org-notes" "org-static" "dot-files"))))
#+END_SRC

   I really, really would like to affect the output of the
   exported/published HTML files to make them /prettier/.

#+BEGIN_SRC elisp
  (setq org-export-html-style "<link rel='stylesheet' href='http://www.howardism.org/styles/org-export-html-style.css' type='text/css'/>
  <script src='http://use.edgefonts.net/source-sans-pro.js'></script>
  <script src='http://use.edgefonts.net/source-code-pro.js'></script>")
#+END_SRC

*** Default Export Settings

    To make the =org-mode= export defaults closer to my liking
    (without having to put specific #+PROPERTY commands), start by
    =describe-variable= the =org-export-plist-vars= variable.

    This returns the list of variables that can be customized:

#+BEGIN_SRC elisp
  (setq org-export-with-section-numbers nil)
  (setq org-export-with-toc nil)
  (setq org-export-skip-text-before-1st-heading nil)

  (setq org-export-html-postamble nil) ;; We don't need any gunk at end

  ; (setq org-export-creator-info nil)
  ; (setq org-export-email-info nil)
  ; (setq org-export-author-info nil)
  ; (setq org-export-time-stamp-file nil)
  ; (setq org-export-html-with-timestamp nil)
#+END_SRC

*** Publishing as Presentation

    Out of all [[http://orgmode.org/worg/org-tutorials/non-beamer-presentations.html][the ideas]] online, I prefer using [[http://meyerweb.com/eric/tools/s5/][S5]], and by loading
    [[https://github.com/eschulte/org-S5/blob/master/org-export-as-s5.el][this code]], we can issue =org-export-as-s5=:

#+BEGIN_SRC elisp
  (autoload 'org-export-as-s5 "org-export-as-s5"
            "Module extension for Presentations for Org-Mode." t nil)
#+END_SRC

    And let's tie this to a keystroke to make it easier to use:

#+BEGIN_SRC elisp
  (global-set-key (kbd "<f9> p") 'org-export-as-s5)
#+END_SRC

*** Publish as Markdown

    Using the [[http://orgmode.org/worg/org-contrib/org-export-generic.php][org-export-generic]] feature, we can export to Markdown
    using =C-c C-e g M=:

#+BEGIN_SRC elisp
  (require 'org-export-generic)
  
  (org-set-generic-type
   "Markdown" 
   '(:file-suffix ".markdown"
     :key-binding ?M
     :title-format "%s\n"
     :title-suffix ?=
     :body-header-section-numbers t
     :body-header-section-number-format "%s) "
     :body-section-header-prefix ("\n## " "\n### " "\n#### " "\n##### " "\n###### ")
     :body-section-header-format  "%s"
     :body-section-header-suffix  "\n\n"
     :todo-keywords-export        t
     :body-line-format            "  %s\n"
     :body-tags-export            t
     :body-tags-prefix            " <tags>"
     :body-tags-suffix            "</tags>\n"
     ;;:body-section-prefix       "<secprefix>\n"
     ;;:body-section-suffix       "</secsuffix>\n"
     :body-line-export-preformated        t
     :body-line-fixed-prefix      "<pre>\n"
     :body-line-fixed-suffix      "\n</pre>\n"
     :body-line-fixed-format      "%s\n"
     :body-list-prefix            "\n"
     :body-list-suffix            "\n"
     :body-list-format            "  * %s\n"
     ;;:body-number-list-prefix   "<ol>\n"
     ;;:body-number-list-suffix   "</ol>\n"
     ;;:body-number-list-format   "<li>%s</li>\n"
     ;;:body-number-list-leave-number     t
     :body-list-checkbox-todo     "[_] "
     :body-list-checkbox-todo-end ""
     :body-list-checkbox-done     "[X] "
     :body-list-checkbox-done-end ""
     :body-line-format            "%s"
     :body-line-wrap               79
     :body-text-prefix            ""
     :body-text-suffix            ""
     ))
#+END_SRC

** The Tower of Babel

   The trick to literate programming is in the [[http://orgmode.org/worg/org-contrib/babel/intro.html][Babel project]], which
   allows org-mode to not only interpret source code blocks, but
   evaluate them and tangle them out to a file.

#+BEGIN_SRC elisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((sh         . t)
   (js         . t)
   (emacs-lisp . t)
   (scala      . t)
   (clojure    . t)
   (python     . t)
   (dot        . t)
   (css        . t)
   (plantuml   . t)))
#+END_SRC

   It seems to automatically recognize the language used in a source
   block, but if not, call =org-babel-lob-ingest= to add all the
   languages from the code block into the list that Babel supports.
   Keystroke: =C-c C-v i=.

*** Font Coloring in Code Blocks
    
    Normally, fontifying the individual code blocks makes it
    impossible to work with, so instead of turning it on at the global
    level for all blocks, I created a couple of keystrokes to
    selectively colorize one block at a time.

#+BEGIN_SRC elisp
  ; (setq org-src-fontify-natively t)
  
  (global-set-key (kbd "<f9> g") 'org-src-fontify-buffer)
  (global-set-key (kbd "<f9> f") 'org-src-fontify-block)
#+END_SRC
* Programming Languages
** Clojure

   Me like Clojure, and since it is a LISP, then Emacs likes it too.

#+BEGIN_SRC elisp
  (if (autofeaturep 'clojure-mode)
      (progn
        (require 'clojure-mode)
        (add-hook 'clojure-mode-hook
                  '(lambda ()
                     (yas/minor-mode-on)))
  
        ;; This makes Compojure macro calls look nicer.
        ;; https://github.com/weavejester/compojure/wiki
        (define-clojure-indent
          (defroutes 'defun)
          (GET 2)
          (POST 2)
          (PUT 2)
          (DELETE 2)
          (HEAD 2)
          (ANY 2)
          (context 2))))
#+END_SRC

   Most LISP-based programming is better with rainbow ponies:

#+BEGIN_SRC elisp
  (if (autofeaturep 'rainbow-delimiters)
      (progn
        (add-hook 'prog-mode-hook  'rainbow-delimiters-mode)
        (add-hook 'nrepl-mode-hook 'rainbow-delimiters-mode)))
#+END_SRC

   With the =elein= project installed, it allows us to do things
   like: =M-x elein-run-cmd koan run=

   Really want to try out my new [[file:~/Dropbox/Clojure/clojuredocs-emacs/org/clojuredocs.org][ClojureDocs functions]]. Note: You
   need to do the following steps:

#+BEGIN_SRC sh :tangle no
  cd ~/Other/... # or whatever
  git clone https://github.com/howardabrams/clojuredocs-emacs.git
  cd ~/.emacs.d
  ln -s ~/Other/clojuredocs-emacs/clojuredocs.el .
#+END_SRC

   Then the following code will work:

#+BEGIN_SRC emacs-lisp
  (if (file-exists-p "~/.emacs.d/clojuredocs.el")
      (load-library "clojuredocs"))
#+END_SRC

*** Paredit

    One of the cooler features of Emacs is the [[http://emacswiki.org/emacs/ParEdit][ParEdit mode]] which
    keeps all parenthesis balanced in Lisp-oriented languages.
    See this [[http://www.emacswiki.org/emacs/PareditCheatsheet][cheatsheet]].

#+BEGIN_SRC elisp
  (autoload 'paredit-mode "paredit"
    "Minor mode for pseudo-structurally editing Lisp code." t)
#+END_SRC

    We need to associate specific language modes with ParEdit.
    We first create a helper function:

#+BEGIN_SRC elisp
  (defun turn-on-paredit () (paredit-mode 1))
#+END_SRC

    Then associate the following Lisp-based modes with ParEdit:

#+BEGIN_SRC elisp
  (add-hook 'emacs-lisp-mode-hook       'turn-on-paredit)
  (add-hook 'lisp-mode-hook             'turn-on-paredit)
  (add-hook 'lisp-interaction-mode-hook 'turn-on-paredit)
  (add-hook 'scheme-mode-hook           'turn-on-paredit)
  (add-hook 'clojure-mode-hook          'turn-on-paredit)
  (add-hook 'nrepl-mode-hook            'turn-on-paredit)
#+END_SRC

    Without the helpful functions, we would have to do something like:

#+BEGIN_SRC elisp :tangle no
  (add-hook 'clojure-mode-hook          (lambda () (paredit-mode +1)))
#+END_SRC

*** ElDoc

    Need to get [[http://emacswiki.org/emacs/ElDoc][ElDoc]] working with Clojure (oh, and with Emacs Lisp).
    Do I need [[https://gist.github.com/tomykaira/1386472][this EL file]]?

#+BEGIN_SRC elisp
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'clojure-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'nrepl-interaction-mode-hook 'nrepl-turn-on-eldoc-mode)
#+END_SRC

*** nREPL and Ritz

  The [[https://github.com/kingtim/nrepl.el][nRepl project]] is da bomb. Usage:

   - =nrepl-jack-in= - For executing regular expressions with nREPL
   - =nrepl-ritz-jack-in= - For debugging expressions with Ritz
   - =nrepl-enable-on-existing-clojure-buffers= for Clojure buffers
     opened prior to starting up the nREPL interface.

  Don't care much for the extra buffers that show up when you start:

#+BEGIN_SRC elisp
  (setq nrepl-hide-special-buffers t)
#+END_SRC

Stop the error buffer from popping up while working in buffers other than the REPL:

#+BEGIN_SRC elisp
  (setq nrepl-popup-stacktraces nil)
#+END_SRC

Make C-c C-z switch to the *nrepl* buffer in the current window:

#+BEGIN_SRC elisp
  (add-to-list 'same-window-buffer-names "*nrepl*")
#+END_SRC

** Scala

   We need to load the [[https://github.com/haxney/scala-mode][scala mode]].
   We follow [[http://www.scala-lang.org/node/354][these instructions]] to hook it up with [[http://code.google.com/p/yasnippet/][Yasnippet]].

#+BEGIN_SRC elisp
  (autoload 'scala-mode "scala-mode"
            "Programming mode for Scala." t nil)

  ;; Shouldn't this be done by default?
  (add-to-list 'auto-mode-alist '("\\.scala$" . scala-mode))
  
  (add-hook 'scala-mode-hook
            '(lambda ()
               (yas/minor-mode-on)
               (scala-mode-feature-electric-mode)))
#+END_SRC

   We follow [[http://jawher.net/2011/01/17/scala-development-environment-emacs-sbt-ensime/][these instructions]] to set it up with [[https://github.com/aemoncannon/ensime][Ensime]].
   Ensime is not available as a package, so I had to download and
   install it, so we need to add it to the =load-path=.

#+BEGIN_SRC elisp
  (if (file-exists-p "~/.emacs.d/ensime")
      (progn
        (add-to-list 'load-path "~/.emacs.d/ensime/elisp")
        (autoload 'ensime-mode "ensime-mode"
          "Programming support mode for Scala." t nil)
        (add-hook 'scala-mode-hook 'ensime-scala-mode-hook)))
#+END_SRC

** JavaScript

   JavaScript should have three parts:
   - Syntax highlight (already included)
   - Syntax verification (with flymake-jshint)
   - Interactive REPL

   Why yes, it seems that the JavaScript mode has a special
   indentation setting. Go below?

#+BEGIN_SRC elisp
  (setq js-basic-indent 2)

  (setq js2-basic-offset 2)
  (setq js2-cleanup-whitespace t)
  (setq js2-enter-indents-newline t)
  (setq js2-global-externs "jQuery $")
  (setq js2-indent-on-enter-key t)
  (setq js2-mode-indent-ignore-first-tab t)

  (autoload 'js2-mode "js2-mode" nil t)
  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+END_SRC

   Change the word "function" to just an "f":

#+BEGIN_SRC elisp
  (font-lock-add-keywords
   'js2-mode `(("\\(function *\\)("
               (0 (progn (compose-region (match-beginning 1) (match-end 1) "Æ’")
                         nil)))))
#+END_SRC

   Place warning font around TODO and others:

#+BEGIN_SRC elisp
  (font-lock-add-keywords 'js2-mode
                          '(("\\<\\(FIX\\|TODO\\|FIXME\\|HACK\\|REFACTOR\\):"
                             1 font-lock-warning-face t)))
#+END_SRC

*** FlyMake and JSHint

   While editing JavaScript is baked into Emacs, it is kinda cool to
   have it give you red sections based on [[http://www.jshint.com/][jshint]].
   This is done with [[http://www.emacswiki.org/emacs/FlymakeJavaScript][FlyMake]].

#+BEGIN_SRC elisp
  ;; Make sure that PATH can reference the 'jshint' executable:
  (setenv "PATH" (concat "/usr/local/bin:/opt/local/bin:" (getenv "PATH")))
  (setq exec-path '( "/usr/local/bin" "/usr/bin" "/opt/local/bin" "/bin"
                     (concat (getenv "HOME") "/bin")))

  (autoload 'flymake-jshint "flymake-jshint"
    "Error and linting support mode for JavaScript." t nil)

  (add-hook 'js-mode-hook
            (lambda () (flymake-mode 1)))
#+END_SRC

   Now load and edit a JavaScript file, like [[file:~/jshint-code-test.js][jshint-code-test.js]].

*** JavaScript REPL

    We can use two different approaches for a JavaScript REPL.
    *Note:* Neither are working very effectively.

**** Client JS with MozRepl

     Assuming you have Mozilla Firefox running with the [[https://addons.mozilla.org/en-US/firefox/addon/mozrepl/][MozRepl]]
     add-on and you've installed a =moz= executable:

#+BEGIN_SRC elisp :tangle no
  (autoload 'moz-minor-mode "moz" "Mozilla Minor and Inferior Mozilla Modes" t)
  
  (add-hook 'js-mode-hook 'javascript-custom-setup)
  (defun javascript-custom-setup ()
    (moz-minor-mode 1))
#+END_SRC

     This gives you the following commands:

     - C-c C-s: open a MozRepl interaction buffer and switch to it
     - C-c C-l: save the current buffer and load it in MozRepl
     - C-M-x: send the current function (as recognized by c-mark-function) to MozRepl
     - C-c C-c: send the current function to MozRepl and switch to the interaction buffer
     - C-c C-r: send the current region to MozRepl

**** Server JS with Node.js

    We use [[http://js-comint-el.sourceforge.net][js-comint]], but hook it up with node.js:

#+BEGIN_SRC elisp
  (autoload 'js-comint "js-comint"
    "Hooking JavaScript interpreter up to the JS Files." t nil)
  
  (setenv "NODE_NO_READLINE" "1")   ;; Turn off fancy node prompt
  ;; Use node as our repl
  (setq inferior-js-program-command "node")
#+END_SRC

    According to [[http://nodejs.org/api/all.html#all_repl][these instructions]], we set the =NODE_NO_READLINE=
    variable.

    Need some prompt configuration for the REPL:

#+BEGIN_SRC elisp
  (setq inferior-js-mode-hook
        (lambda ()
          ;; We like nice colors
          (ansi-color-for-comint-mode-on)
          ;; Deal with some prompt nonsense
          (add-to-list
           'comint-preoutput-filter-functions
           (lambda (output)
             (replace-regexp-in-string "\033\\[[0-9]+[GK]" "" output)
             (replace-regexp-in-string ".*1G.*3G" "&GT;" output)
             (replace-regexp-in-string "&GT;" "> " output)
  ))))
#+END_SRC

    Now, we can start up a JavaScript node REPL: =run-js=

    Let's test this out by loading this into a separate buffer (=C-c '=)
    and then doing a =M-x send-buffer-and-go=.

    Set up some helpful keyboard instructions:

#+BEGIN_SRC elisp
  (add-hook 'js2-mode-hook
          (lambda () 
            (local-set-key (kbd "C-x C-e") #'js-send-buffer-and-go)
            (local-set-key (kbd "C-x r")   #'run-js)))
#+END_SRC

    Wanna try it all out?

#+BEGIN_SRC js2 :tangle no
  function factorial(n) { 
    return n == 0 ? 1 : n * factorial(n - 1);
  }
  factorial(16);
#+END_SRC

** Java
*** JSP

    Dealing with [[http://www.emacswiki.org/emacs/JspMode][JSP files]] is bad. But we'll try the [[http://www.crossleys.org/~jim/work/jsp.el][jsp-mode]] first:

#+BEGIN_SRC elisp
    ; (autoload 'jsp-mode "jsp" "JSP" t)

    ; Tell emacs to use jsp-mode for .jsp files
    (add-to-list 'auto-mode-alist '("\\.jsp\\'" . html-mode))
#+END_SRC

** Python

   Must install a few new packages:

   - jedi (Not working from ELPA)
   - flymake-python
   - nose

#+BEGIN_SRC elisp
  (require 'nose)
  
  (add-hook 'python-mode-hook 'auto-complete-mode)
  ;;; (add-hook 'python-mode-hook 'jedi:ac-setup)
#+END_SRC

     Include this line only for people with non-eco non-global test
     runners... like the Python Koans:

#+BEGIN_SRC elisp :tangle no
(add-to-list 'nose-project-names "~/Google\ Drive/python_koans/python2")
#+END_SRC


   Got iPython and EIN? Great!

#+BEGIN_SRC elisp
  (add-to-list 'load-path "~/.emacs.d/ipython-notebook/lisp/")
  (require 'ein)
  (setq ein:use-auto-complete t)
#+END_SRC

* Tools
** Git

   Git is [[http://emacswiki.org/emacs/Git][already part of Emacs]]. However, [[http://philjackson.github.com/magit/magit.html][Magit]] is sweet.
   
#+BEGIN_SRC elisp
  (autoload 'magint "magit"
    "Hooking Git up to supported files." t nil)

  (global-set-key (kbd "M-C-g") 'magit-status)
#+END_SRC

** Markdown

   Don't use Markdown nearly as much as I used to, but I'm surprised
   that the following extension-associations aren't the default:

#+BEGIN_SRC elisp
  (autoload 'markdown-mode "markdown-mode.el"
     "Major mode for editing Markdown files" t)
  (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.txt\\'" . markdown-mode))
#+END_SRC   

   Using the =org-text-wrapper= function, we create some wrapper
   functions to make it easier to bold text in Markdown files:

#+BEGIN_SRC elisp
  (defun markdown-bold () "Wraps the region with double asterisks."
    (interactive)
    (org-text-wrapper "**"))
  (defun markdown-italics () "Wraps the region with asterisks."
    (interactive)
    (org-text-wrapper "*"))
  (defun markdown-code () "Wraps the region with equal signs."
    (interactive)
    (org-text-wrapper "`"))
#+END_SRC

   Now we can associate some keystrokes to =markdown-mode=:

#+BEGIN_SRC elisp
  (add-hook 'markdown-mode-hook
        (lambda ()
          (local-set-key (kbd "A-b") 'markdown-bold)
          (local-set-key (kbd "A-i") 'markdown-italics)
          (local-set-key (kbd "A-=") 'markdown-code)))
#+END_SRC

** Wiki

   Now that Atlassian changed this Wiki system so that [[https://code.google.com/p/confluence-el/][confluence.el]]
   doesn't work anymore (yeah, not an improvement, Atlassian), I can
   still use the =confluence-edit-mode= for anything with a =.wiki=
   extension.

#+BEGIN_SRC elisp
  (autoload 'confluence-edit-mode "confluence-edit-mode.el"
     "Major mode for editing Wiki documents" t)
  (add-to-list 'auto-mode-alist '("\\.wiki\\'" . confluence-edit--mode))
#+END_SRC

   I would also like to create and use some formatting wrappers.

#+BEGIN_SRC elisp
  (defun wiki-bold () "Wraps the region with single asterisks."
    (interactive)
    (org-text-wrapper "*"))
  (defun wiki-italics () "Wraps the region with underbars."
    (interactive)
    (org-text-wrapper "_"))
  (defun wiki-code () "Wraps the region with curly brackets."
    (interactive)
    (org-text-wrapper "{{" "}}"))
#+END_SRC

   Now we can associate some keystrokes to =markdown-mode=:

#+BEGIN_SRC elisp
  (add-hook 'confluence-edit-mode-hook
        (lambda ()
          (local-set-key (kbd "A-b") 'wiki-bold)
          (local-set-key (kbd "A-i") 'wiki-italics)
          (local-set-key (kbd "A-=") 'wiki-code)))
#+END_SRC

** Eshell

   E-shell doesn't read the [[http://www.emacswiki.org/emacs/EshellAlias][standard shell resource]] files or allow
   shell functions and aliases, so we need to create emacs-specific
   ones:

#+BEGIN_SRC elisp
  (defun eshell/e (file)
    (find-file file))
  (defun eshell/emacs (file)
    (find-file file))
#+END_SRC

   Replacing the window with the new buffer may not be what I want.
 
#+BEGIN_SRC elisp
  (defun eshell/ee (file)
    (find-file-other-window file))
#+END_SRC

** PlantUML

   To get [[http://plantuml.sourceforge.net/download.html][PlantUML]] working in Emacs, first, we need to get the "mode"
   working for editing the files:

#+BEGIN_SRC elisp
  (setq plantuml-jar-path (concat (getenv "HOME") "/bin/plantuml.jar"))
#+END_SRC

   Second, to get [[http://zhangweize.wordpress.com/2010/08/25/creating-uml-images-by-using-plantuml-and-org-babel-in-emacs/][PlantUML]] working in org-mode, we set a different variable:

#+BEGIN_SRC elisp
  (setq org-plantuml-jar-path (concat (getenv "HOME") "/bin/plantuml.jar"))
#+END_SRC

** Mail with Gnus

   I would like to hook up my [[http://www.emacswiki.org/emacs/GnusGmail][Gmail with GNUS mail reader]].
   See these [[http://www.mostlymaths.net/2010/12/emacs-30-day-challenge-using-gnus-to.html][detailed instructions]] if we run into problems.
   The instructions are contained in [[file:gnus.org][gnus.org]] file.

#+BEGIN_SRC elisp
  (if (file-exists-p "~/.emacs.d/gnus-config.el")
    (load-library "gnus-config"))
#+END_SRC

** Reading Mail?

   Well, Gnus is pretty gunky. It works, but ...

#+BEGIN_SRC elisp :tangle no
(autoload 'vm "~/vm" "Start VM on your primary inbox." t)
(autoload 'vm-visit-folder "~/vm" "Start VM on an arbitrary folder." t)
(autoload 'vm-mail "~/vm" "Send a mail message using VM." t)
(autoload 'vm-submit-bug-report "~/vm" "Send a bug report about VM." t)
#+END_SRC
* Final Thoughts

  Order sometimes matter, and this section is specially applied at
  the end of the file.

** Overriding Keybindings

   You would think that you could just set the keybindings you want
   at the top of your file, and be good, but since modules like to
   add their own binding, I want to override some of them:

   Rebind =C-x C-y= to the Yas expand function:

#+BEGIN_SRC elisp
  (global-set-key (kbd "C-x C-y") 'yas/expand)
#+END_SRC

* Technical Artifacts

  Before you can build this on a new system, make sure that you put
  the cursor over any of these properties, and hit: =C-c C-c=

#+DESCRIPTION: A literate programming version of my Emacs Initialization script, loaded by the .emacs file.
#+PROPERTY:    results silent
#+PROPERTY:    tangle ~/.emacs-ext.el
#+PROPERTY:    eval no-export
#+PROPERTY:    comments org
#+OPTIONS:     num:nil toc:nil todo:nil tasks:nil tags:nil
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
